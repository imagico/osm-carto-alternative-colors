# This is generated code, do not change this file manually.
#
# To change these definitions, alter layers/*.mml and run:
#
#   ./scripts/assemble_project.py
#
# Content subject to AGPL v3.0/CC BY-SA 4.0 - see LICENSE.txt for details
#
scale: 1
metatile: 2
name: OSM-Carto alternative colors
description: An experimental fork of OSM-Carto
license: AGPL v3.0/CC BY-SA 4.0 - see LICENSE.txt for details
bounds: &world
  - -180
  - -85.05112877980659
  - 180
  - 85.05112877980659
center:
  - 0
  - 0
  - 4
format: png
interactivity: false
minzoom: 0
maxzoom: 22
srs: "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0.0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs +over"

# Various parts to be included later on
_parts:
  # Extents are used for tilemill, and don't actually make it to the generated XML
  extents: &extents
    extent: *world
    srs-name: "3857"
    srs: "+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0.0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs +over"
  extents84: &extents84
    extent: *world
    srs-name: "WGS84"
    srs: "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
  osm2pgsql: &osm2pgsql
    type: "postgis"
    dbname: "gis"
    key_field: ""
    geometry_field: "way"
    extent: "-20037508,-20037508,20037508,20037508"
Stylesheet:
  - style/style.mss
  - style/fonts.mss
  - style/landcover.mss
  - style/shapefiles.mss
  - style/water.mss
  - style/roads.mss
  - style/water-features.mss
  - style/buildings.mss
  - style/ferry-routes.mss
  - style/road-colors-generated.mss
  - style/line-widths-generated.mss
  - style/golf.mss
  - style/aerialways.mss
  - style/admin.mss
  - style/power.mss
  - style/amenity-points.mss
  - style/placenames.mss
  - style/symbols-labels-generated.mss
  - style/addressing.mss
Layer:
  - id: landcover-low-zoom
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way, COALESCE(name_label[1], '') AS name, way_pixels, religion,
            COALESCE(wetland, landuse, "natural") AS feature
          FROM (SELECT
              way, carto_label_name(way, name, tags, E'\n') AS name_label, religion,
              ('landuse_' || (CASE WHEN landuse IN ('forest', 'military') THEN landuse ELSE NULL END)) AS landuse,
              ('natural_' || (CASE WHEN "natural" IN ('wood', 'sand', 'scree', 'shingle', 'bare_rock', 'beach') THEN "natural" ELSE NULL END)) AS "natural",
              ('wetland_' || (CASE WHEN "natural" IN ('wetland', 'mud') THEN (CASE WHEN "natural" IN ('mud') THEN "natural" ELSE tags->'wetland' END) ELSE NULL END)) AS wetland,
              way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels
            FROM planet_osm_polygon
            WHERE (landuse IN ('forest', 'military')
              OR "natural" IN ('wood', 'wetland', 'mud', 'sand', 'scree', 'shingle', 'bare_rock', 'beach'))
              AND way_area > 0.01*!pixel_width!::real*!pixel_height!::real
              AND building IS NULL
            ORDER BY COALESCE(layer,0), way_area DESC
          ) AS features
        ) AS landcover_low_zoom
    properties:
      cache-features: true
      minzoom: 7
      maxzoom: 9
  - id: landcover
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            name,
            religion,
            crop,
            surface,
            sport,
            way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels,
            feature
          FROM (SELECT
              way, COALESCE(name_label[1], '') AS name, religion, crop, surface, sport, way_area, layer,
              COALESCE(aeroway, golf, amenity, wetland, power, landuse, leisure, military, "natural", tourism, highway, railway) AS feature
            FROM (SELECT
                way, carto_label_name(way, name, tags, E'\n') AS name_label,
                ('aeroway_' || (CASE WHEN aeroway IN ('apron', 'aerodrome') THEN aeroway ELSE NULL END)) AS aeroway,
                ('golf_' || (CASE WHEN (tags->'golf') IN ('rough', 'fairway', 'driving_range', 'water_hazard', 'green', 'bunker') THEN tags->'golf' ELSE NULL END)) AS golf,
                ('amenity_' || (CASE WHEN amenity IN ('parking', 'bicycle_parking', 'motorcycle_parking', 'university', 'college', 'school',
                                                      'hospital', 'kindergarten', 'grave_yard', 'prison', 'place_of_worship', 'clinic')
                                                      THEN amenity ELSE NULL END)) AS amenity,
                ('landuse_' || (CASE WHEN landuse IN ('quarry', 'vineyard', 'orchard', 'cemetery', 'residential', 'garages', 'meadow', 'grass',
                                                      'allotments', 'forest', 'farmyard', 'farmland', 'greenhouse_horticulture',
                                                      'recreation_ground', 'village_green', 'retail', 'industrial', 'railway', 'commercial',
                                                      'brownfield', 'landfill', 'construction', 'plant_nursery', 'salt_pond') THEN landuse ELSE NULL END)) AS landuse,
                ('leisure_' || (CASE WHEN leisure IN ('swimming_pool', 'playground', 'park', 'recreation_ground', 'common', 'garden',
                                                      'golf_course', 'miniature_golf', 'picnic_table', 'fitness_centre', 'sports_centre', 'stadium', 'pitch',
                                                      'track', 'dog_park') THEN leisure ELSE NULL END)) AS leisure,
                ('military_' || (CASE WHEN military IN ('danger_area') THEN military ELSE NULL END)) AS military,
                ('natural_' || (CASE WHEN "natural" IN ('beach', 'shoal', 'heath', 'grassland', 'wood', 'sand', 'scree', 'shingle', 'bare_rock', 'scrub') THEN "natural" ELSE NULL END)) AS "natural",
                ('wetland_' || (CASE WHEN "natural" IN ('wetland', 'mud') THEN (CASE WHEN "natural" IN ('mud') THEN "natural" ELSE tags->'wetland' END) ELSE NULL END)) AS wetland,
                ('power_' || (CASE WHEN power IN ('station', 'sub_station', 'substation', 'generator') THEN power ELSE NULL END)) AS power,
                ('tourism_' || (CASE WHEN tourism IN ('attraction', 'camp_site', 'caravan_site', 'picnic_site') THEN tourism ELSE NULL END)) AS tourism,
                ('highway_' || (CASE WHEN highway IN ('services', 'rest_area') THEN highway ELSE NULL END)) AS highway,
                ('railway_' || (CASE WHEN railway = 'station' THEN railway ELSE NULL END)) AS railway,
                CASE WHEN religion IN ('christian', 'jewish', 'muslim') THEN religion ELSE 'INT-generic'::text END AS religion,
                CASE WHEN landuse IN ('farmland') THEN tags->'crop' ELSE tags->'trees' END AS crop,
                surface,
                (tags->'sport') AS sport,
                way_area, layer
              FROM planet_osm_polygon
              WHERE (landuse IS NOT NULL
                OR leisure IS NOT NULL
                OR (tags->'golf') IS NOT NULL
                OR aeroway IN ('apron', 'aerodrome')
                OR amenity IN ('parking', 'bicycle_parking', 'motorcycle_parking', 'university', 'college', 'school', 'hospital', 'kindergarten',
                               'grave_yard', 'place_of_worship', 'prison', 'clinic')
                OR military IN ('danger_area')
                OR "natural" IN ('beach', 'shoal', 'heath', 'mud', 'wetland', 'grassland', 'wood', 'sand', 'scree', 'shingle', 'bare_rock', 'scrub')
                OR power IN ('station', 'sub_station', 'substation', 'generator')
                OR tourism IN ('attraction', 'camp_site', 'caravan_site', 'picnic_site')
                OR highway IN ('services', 'rest_area')
                OR railway = 'station')
                AND way_area > 0.01*!pixel_width!::real*!pixel_height!::real
            ) AS landcover
          ) AS landcover_all
          ORDER BY COALESCE(layer,0), way_area DESC
        ) AS features
    properties:
      cache-features: true
      minzoom: 10
  - id: builtup
    geometry: polygon
    extent: *world
    srs-name: mercator
    srs: "+proj=merc +datum=WGS84 +over"
    Datasource:
      file: data/world_boundaries/builtup_area.shp
      type: shape
    properties:
      minzoom: 8
      maxzoom: 9
  - id: landcover-line
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM planet_osm_line
          WHERE man_made = 'cutline'
        ) AS landcover_line
    properties:
    minzoom: 14
  - id: icesheet-poly
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM icesheet_polygons
        ) AS icesheet_polygons
    properties:
      minzoom: 4
  - id: water-lines-casing
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            waterway,
            tags->'intermittent' as intermittent,
            tags->'seasonal' as seasonal,
            CASE WHEN tunnel IN ('yes', 'culvert') THEN 'yes' ELSE 'no' END AS int_tunnel
          FROM planet_osm_line
          WHERE waterway IN ('stream', 'drain', 'ditch')
        ) AS water_lines_casing
    properties:
      minzoom: 12
  - id: rivers-z0
    class: "rivers"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/river-polygons-reduced-3857/river_reduced_z0.shp"
      type: "shape"
    properties:
      maxzoom: 0
    advanced: {}
  - id: rivers-z1
    class: "rivers"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/river-polygons-reduced-3857/river_reduced_z1.shp"
      type: "shape"
    properties:
      minzoom: 1
      maxzoom: 1
    advanced: {}
  - id: rivers-z2
    class: "rivers"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/river-polygons-reduced-3857/river_reduced_z2.shp"
      type: "shape"
    properties:
      minzoom: 2
      maxzoom: 2
    advanced: {}
  - id: rivers-z3
    class: "rivers"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/river-polygons-reduced-3857/river_reduced_z3.shp"
      type: "shape"
    properties:
      minzoom: 3
      maxzoom: 3
    advanced: {}
  - id: rivers-z4
    class: "rivers"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/river-polygons-reduced-3857/river_reduced_z4.shp"
      type: "shape"
    properties:
      minzoom: 4
      maxzoom: 4
    advanced: {}
  - id: rivers-z5
    class: "rivers"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/river-polygons-reduced-3857/river_reduced_z5.shp"
      type: "shape"
    properties:
      minzoom: 5
      maxzoom: 5
    advanced: {}
  - id: rivers-z6
    class: "lakes"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/river-polygons-reduced-3857/river_reduced_z6.shp"
      type: "shape"
    properties:
      minzoom: 6
      maxzoom: 6
    advanced: {}
  - id: lakes-z0
    class: "lakes"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/lakes-polygons-reduced-3857/lakes_reduced_z0.shp"
      type: "shape"
    properties:
      maxzoom: 0
    advanced: {}
  - id: lakes-z1
    class: "lakes"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/lakes-polygons-reduced-3857/lakes_reduced_z1.shp"
      type: "shape"
    properties:
      minzoom: 1
      maxzoom: 1
    advanced: {}
  - id: lakes-z2
    class: "lakes"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/lakes-polygons-reduced-3857/lakes_reduced_z2.shp"
      type: "shape"
    properties:
      minzoom: 2
      maxzoom: 2
    advanced: {}
  - id: lakes-z3
    class: "lakes"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/lakes-polygons-reduced-3857/lakes_reduced_z3.shp"
      type: "shape"
    properties:
      minzoom: 3
      maxzoom: 3
    advanced: {}
  - id: lakes-z4
    class: "lakes"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/lakes-polygons-reduced-3857/lakes_reduced_z4.shp"
      type: "shape"
    properties:
      minzoom: 4
      maxzoom: 4
    advanced: {}
  - id: lakes-z5
    class: "lakes"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/lakes-polygons-reduced-3857/lakes_reduced_z5.shp"
      type: "shape"
    properties:
      minzoom: 5
      maxzoom: 5
    advanced: {}
  - id: lakes-z6
    class: "lakes"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/lakes-polygons-reduced-3857/lakes_reduced_z6.shp"
      type: "shape"
    properties:
      minzoom: 6
      maxzoom: 6
    advanced: {}
  - id: water-areas
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            "natural",
            waterway,
            water,
            tags->'intermittent' as intermittent,
            tags->'seasonal' as seasonal,
            tags->'salt' as salt,
            tags->'glacier:type' as glacier_type,
            landuse,
            way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels
          FROM planet_osm_polygon
          WHERE
            (waterway IN ('dock', 'riverbank')
              OR landuse IN ('reservoir', 'basin')
              OR "natural" IN ('water', 'glacier'))
            AND (landuse IS NULL OR landuse NOT IN ('salt_pond'))
            AND building IS NULL
            AND way_area > 0.01*!pixel_width!::real*!pixel_height!::real
          ORDER BY COALESCE(layer,0), way_area DESC
        ) AS water_areas
    properties:
      minzoom: 7
  - id: ocean-z0
    class: "ocean"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/ocean-polygons-reduced-3857/ocean_reduced_z0.shp"
      type: "shape"
    properties:
      maxzoom: 0
    advanced: {}
  - id: ocean-z1
    class: "ocean"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/ocean-polygons-reduced-3857/ocean_reduced_z1.shp"
      type: "shape"
    properties:
      minzoom: 1
      maxzoom: 1
    advanced: {}
  - id: ocean-z2
    class: "ocean"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/ocean-polygons-reduced-3857/ocean_reduced_z2.shp"
      type: "shape"
    properties:
      minzoom: 2
      maxzoom: 2
    advanced: {}
  - id: ocean-z3
    class: "ocean"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/ocean-polygons-reduced-3857/ocean_reduced_z3.shp"
      type: "shape"
    properties:
      minzoom: 3
      maxzoom: 3
    advanced: {}
  - id: ocean-z4
    class: "ocean"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/ocean-polygons-reduced-3857/ocean_reduced_z4.shp"
      type: "shape"
    properties:
      minzoom: 4
      maxzoom: 4
    advanced: {}
  - id: ocean-z5
    class: "ocean"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/ocean-polygons-reduced-3857/ocean_reduced_z5.shp"
      type: "shape"
    properties:
      minzoom: 5
      maxzoom: 5
    advanced: {}
  - id: ocean-z6
    class: "ocean"
    geometry: "polygon"
    <<: *extents
    Datasource:
      file: "data/ocean-polygons-reduced-3857/ocean_reduced_z6.shp"
      type: "shape"
    properties:
      minzoom: 6
      maxzoom: 6
    advanced: {}
  - id: ocean-lz
    class: "ocean"
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM simplified_water_polygons
        ) AS ocean_lz
    properties:
      minzoom: 7
      maxzoom: 9
  - id: ocean
    class: "ocean"
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM water_polygons
        ) AS ocean
    properties:
      minzoom: 10
  - id: landcover-water
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            surface,
            "natural",
            CASE WHEN "natural" IN ('mud') 
                THEN "natural" 
                ELSE CASE WHEN ("natural" = 'wetland' AND NOT tags ? 'wetland') 
                  THEN 'wetland' 
                  ELSE CASE WHEN ("natural" = 'wetland')
                    THEN tags->'wetland'
                    ELSE NULL
                    END 
                END
            END AS int_wetland,
            way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels
          FROM planet_osm_polygon
          WHERE "natural" IN ('mud', 'wetland', 'beach', 'shoal', 'scree', 'shingle', 'bare_rock')
            AND building IS NULL
            AND way_area > 0.01*!pixel_width!::real*!pixel_height!::real
          ORDER BY COALESCE(layer,0), way_area DESC
        ) AS landcover_water
    properties:
      minzoom: 7
  - id: water-lines-low-zoom
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            waterway,
            tags->'intermittent' as intermittent,
            tags->'seasonal' as seasonal
          FROM planet_osm_line
          WHERE waterway = 'river'
        ) AS water_lines_low_zoom
    properties:
      minzoom: 8
      maxzoom: 11
  - id: water-lines
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            ('waterway_' || waterway) AS feature,
            tags->'intermittent' as intermittent,
            tags->'seasonal' as seasonal,
            CASE WHEN tunnel IN ('yes', 'culvert') THEN 'yes' ELSE 'no' END AS int_tunnel,
            'no' AS int_bridge
          FROM planet_osm_line
          WHERE waterway IN ('river', 'canal', 'stream', 'drain', 'ditch')
            AND (bridge IS NULL OR bridge NOT IN ('yes', 'aqueduct'))
            ORDER BY
              COALESCE(layer,0),
              CASE WHEN waterway IN ('drain', 'ditch') THEN 1 WHEN waterway IN ('canal') THEN 2 ELSE 3 END
        ) AS water_lines
    properties:
      minzoom: 12
  - id: ocean-lz-backdrop
    class: "ocean-backdrop"
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM simplified_water_polygons
        ) AS ocean_lz
    properties:
      minzoom: 7
      maxzoom: 9
  - id: ocean-backdrop
    class: "ocean-backdrop"
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM water_polygons
        ) AS ocean
    properties:
      minzoom: 10
  - id: river-areas-backdrop
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            "natural",
            waterway,
            water,
            tags->'intermittent' as intermittent,
            tags->'seasonal' as seasonal,
            way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels
          FROM planet_osm_polygon
          WHERE
            (waterway IN ('riverbank')
              OR ("natural" IN ('water') AND water IN ('river', 'canal')))
            AND (landuse IS NULL OR landuse NOT IN ('salt_pond'))
            AND building IS NULL
            AND way_area > 0.01*!pixel_width!::real*!pixel_height!::real
          ORDER BY COALESCE(layer,0), way_area DESC
        ) AS river_areas_backdrop
    properties:
      minzoom: 7
  - id: saltwater-areas-backdrop
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            "natural",
            waterway,
            water,
            tags->'intermittent' as intermittent,
            tags->'seasonal' as seasonal,
            tags->'salt' as salt,
            landuse,
            way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels
          FROM planet_osm_polygon
          WHERE
            (waterway IN ('dock')
              OR landuse IN ('reservoir', 'basin')
              OR "natural" IN ('water'))
            AND (landuse IS NULL OR landuse NOT IN ('salt_pond'))
            -- water = ocean is for testing only
            AND ((tags @> 'salt=>yes') OR water = 'ocean')
            AND building IS NULL
            AND way_area > 0.01*!pixel_width!::real*!pixel_height!::real
          ORDER BY COALESCE(layer,0), way_area DESC
        ) AS saltwater_areas
    properties:
      minzoom: 7
  - id: water-areas-backdrop
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            ST_MakeEnvelope(-20037508.342789244, -20037508.342789244, 20037508.342789244, 20037508.342789244, 3857) AS way
        ) AS water_areas_backdrop
    properties:
      minzoom: 7
  - id: landcover-area-symbols
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            CASE WHEN ("natural" in ('reef')) THEN tags->'reef' ELSE surface END AS surface,
            COALESCE(CASE WHEN landuse = 'forest' THEN 'wood' ELSE NULL END, "natural") AS "natural",
            CASE WHEN "natural" IN ('mud') 
                THEN "natural" 
                ELSE CASE WHEN ("natural" = 'wetland' AND NOT tags ? 'wetland') 
                  THEN 'wetland' 
                  ELSE CASE WHEN ("natural" = 'wetland')
                    THEN tags->'wetland'
                    ELSE NULL
                    END
                END
            END AS int_wetland,
            tags->'leaf_type' AS leaf_type,
            tags->'leaf_cycle' AS leaf_cycle,
            way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels
          FROM planet_osm_polygon
          WHERE ("natural" IN ('mud', 'wetland', 'wood', 'scrub', 'reef') OR landuse = 'forest')
            AND building IS NULL
            AND way_area > 0.01*!pixel_width!::real*!pixel_height!::real
          ORDER BY COALESCE(layer,0), way_area DESC
        ) AS landcover_area_symbols
    properties:
      cache-features: true
      minzoom: 7
  - id: icesheet-outlines
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            ice_edge
          FROM icesheet_outlines
        ) AS icesheet_outlines
    properties:
      minzoom: 4
  - id: cliffs
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way, "natural", man_made
          FROM planet_osm_line
          WHERE ("natural" IN ('cliff', 'earth_bank') OR man_made = 'embankment')
            AND way && !bbox!
         UNION ALL
         SELECT
            ST_Difference(
              way,
              (SELECT ST_Union(ST_Buffer(way, 6*NULLIF(!scale_denominator!*0.001*0.28,0)))
                 FROM planet_osm_point p
                 WHERE ("natural" IN ('peak', 'volcano', 'saddle') OR (tags @> 'mountain_pass=>yes'))
                   AND ST_DWithin(l.way, p.way, 6*NULLIF(!scale_denominator!*0.001*0.28,0))
              )
            ) AS way, "natural", man_made
          FROM planet_osm_line l
          WHERE "natural" IN ('ridge', 'arete')
            AND l.way && !bbox!
        ) AS cliffs
    properties:
      minzoom: 13
  - id: highway-embankments
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            ST_Difference(
              ST_Boundary(way),
              -- this clips the embankment/cutting outlines with the adjacent lines that are not embankment/cutting
              (SELECT
                  COALESCE(
                    ST_Union(ST_Buffer(ST_Intersection(o.way, l.way),
                      (0.5*
                        CASE WHEN o.barrier = 'hedge' THEN
                          GREATEST(
                            carto_highway_line_width(COALESCE(o.highway, o.railway, o.waterway, o.man_made, o.barrier), o.service, z(!scale_denominator!)),
                            LEAST(carto_treerow_line_width_mapped(o.barrier, o.tags->'width', o.tags->'height', !bbox!, !scale_denominator!), 60)
                          )
                        ELSE
                          GREATEST(
                            carto_highway_line_width(COALESCE(o.highway, o.railway, o.waterway, o.man_made, o.barrier), o.service, z(!scale_denominator!)),
                            carto_highway_line_width_mapped(o.highway, o.tags->'width', o.tags->'lanes', !bbox!, !scale_denominator!)
                          ) +
                          (CASE WHEN
                            z(!scale_denominator!) >= 18 AND
                            ((o.tags->'sidewalk') IN ('yes', 'both', 'left', 'right') OR
                             (o.tags->'sidewalk:left') IN ('yes') OR
                             (o.tags->'sidewalk:right') IN ('yes') OR
                             (o.tags->'cycleway') IN ('track') OR
                             (o.tags->'cycleway:left')  IN ('track') OR
                             (o.tags->'cycleway:right') IN ('track')) THEN 7.5
                           WHEN
                            z(!scale_denominator!) >= 18 AND
                            ((o.tags->'handrail') IN ('yes') OR
                             (o.tags->'handrail:left') IN ('yes') OR
                             (o.tags->'handrail:right') IN ('yes')) THEN 4.0
                           ELSE 0.0 END)
                        END + 5.0
                      )*NULLIF(!scale_denominator!*0.001*0.28,0))),
                      ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                  )
                FROM planet_osm_line o
                WHERE (o.highway IS NOT NULL OR o.railway IS NOT NULL OR o.man_made = 'dyke' OR o.barrier = 'hedge' OR o.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain')) AND
                  carto_highway_line_width(COALESCE(o.highway, o.railway, o.waterway, o.man_made, o.barrier), o.service, z(!scale_denominator!)) > 0.0 AND
                  ST_DWithin(l.line, o.way, 0.1) AND
                  o.way && ST_Expand(!bbox!, (0.5*carto_highway_line_width('motorway', z(!scale_denominator!)) + 10.0)*NULLIF(!scale_denominator!*0.001*0.28,0)) AND
                  (
                    (l.type = 'cutting' AND NOT(o.tags @> 'cutting=>yes')) OR
                    (l.type = 'embankment' AND NOT(o.tags @> 'embankment=>yes')) OR
                    (l.type = 'hedge_bank' AND NOT(o.tags @> 'hedge=>hedge_bank')) OR
                    (l.type = 'dyke' AND (o.man_made IS NULL OR o.man_made NOT IN ('dyke')))
                  )
              )
            ) AS way,
            type
          FROM
            -- this queries the lines with embankment/cutting and buffers + aggregates them separately for embankment and cutting
            (SELECT
                ST_Union(ST_Buffer(way, (0.5*width_px + 2.5)*NULLIF(!scale_denominator!*0.001*0.28,0))) AS way,
                ST_Collect(way) AS line,
                type
              FROM
                (SELECT
                    way,
                    GREATEST(
                      carto_highway_line_width(COALESCE(highway, railway, waterway, man_made, barrier), service, z(!scale_denominator!)),
                      carto_highway_line_width_mapped(highway, tags->'width', tags->'lanes', !bbox!, !scale_denominator!)) + 
                    (CASE WHEN
                      z(!scale_denominator!) >= 18 AND
                      ((tags->'sidewalk') IN ('yes', 'both', 'left', 'right') OR
                       (tags->'sidewalk:left') IN ('yes') OR
                       (tags->'sidewalk:right') IN ('yes') OR
                       (tags->'cycleway') IN ('track') OR
                       (tags->'cycleway:left')  IN ('track') OR
                       (tags->'cycleway:right') IN ('track')) THEN 7.5
                      WHEN
                       z(!scale_denominator!) >= 18 AND
                       ((tags->'handrail') IN ('yes') OR
                        (tags->'handrail:left') IN ('yes') OR
                        (tags->'handrail:right') IN ('yes')) THEN 4.0
                      ELSE 0.0 END) AS width_px,
                    (CASE
                       WHEN (tags @> 'cutting=>yes') THEN 'cutting'
                       WHEN (man_made = 'dyke') THEN 'dyke'
                       WHEN (barrier = 'hedge') THEN 'hedge_bank'
                       ELSE 'embankment'
                    END) AS type
                  FROM planet_osm_line
                  WHERE ((man_made = 'dyke') OR (barrier = 'hedge' AND (tags @> 'hedge=>hedge_bank')) OR
                    ((highway IS NOT NULL OR railway IS NOT NULL OR (man_made = 'dyke') OR waterway IN ('river', 'canal', 'stream', 'ditch', 'drain'))
                    AND ((tags @> 'embankment=>yes') OR (tags @> 'cutting=>yes'))))
                    AND way && ST_Expand(!bbox!, (0.5*carto_highway_line_width('motorway', z(!scale_denominator!)) + 10.0)*NULLIF(!scale_denominator!*0.001*0.28,0))
                ) AS embankments
              WHERE width_px > 0.0
              GROUP BY type
            ) AS l
        ) AS highway_embankments
    properties:
      minzoom: 16
  - id: marinas-area
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM planet_osm_polygon
          WHERE leisure = 'marina'
        ) AS marinas_area
    properties:
      minzoom: 14
  - id: water-barriers-line-simple
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (-- All of this assumes a metric coordinate system, won't work with geographic coordinates
         -- This is the simplified version of the water-barrier rendering:
         --  * always rendering lines and polygon directly
         --  * construct lines from nodes but not take riverbank polygons into account there
         -- First query: barriers mapped using ways
         SELECT
            way,
            waterway,
            'line' AS wtype
          FROM planet_osm_line b
          WHERE waterway IN ('dam', 'weir', 'lock_gate') AND (b.way && !bbox!)
         UNION ALL
         -- Second query: barriers mapped using polygons
         SELECT
            way,
            waterway,
            'polygon' AS wtype
          FROM planet_osm_polygon b
          WHERE waterway IN ('dam', 'weir', 'lock_gate') AND (b.way && !bbox!)
         UNION ALL
         -- Fifth query: barriers mapped using nodes on a waterway
         SELECT
             ST_MakeLine(ARRAY[
               ST_Rotate(
                 ST_SetSRID(ST_MakePoint(
                 ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line),
                 ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line)
               ), 3857), -angle, point),
               point,
               ST_Rotate(
                 ST_SetSRID(ST_MakePoint(
                 ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line),
                 ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line)
               ), 3857), angle, point)
             ]) AS way,
             waterway,
             wtype
           FROM
             -- outer query: points with nominal contructed waterway width
             -- in this simplified version we do not do the riverbank polygon analysis
             (SELECT
                 point,
                 line,
                 waterway,
                 wtype,
                 contructed_width,
                 angle
               FROM
                 -- inner query: points with nominal contructed waterway width
                 (SELECT DISTINCT ON (p.osm_id)
                     p.way AS point,
                     ST_LineSubstring(
                       l.way,
                       GREATEST(0.0, ST_LineLocatePoint(l.way, p.way)-1.0/ST_Length(l.way)),
                       LEAST(1.0, ST_LineLocatePoint(l.way, p.way)+1.0/ST_Length(l.way))) AS line,
                     p.waterway AS waterway,
                     l.waterway AS wtype,
                     (carto_waterway_line_width(l.waterway, z(!scale_denominator!)) +
                       (CASE WHEN p.waterway =  'waterfall' THEN 2 ELSE 0 END) +
                       (CASE WHEN l.waterway IN ('river', 'canal') THEN 0 ELSE 0.5 END)) *
                         NULLIF(!scale_denominator!*0.001*0.28,0) AS contructed_width,
                     (CASE WHEN p.waterway =  'lock_gate' THEN pi()/2.3 ELSE pi()/2 END) AS angle
                   FROM planet_osm_point p
                   JOIN planet_osm_line l ON ST_DWithin(p.way, l.way, 0.1)
                   WHERE p.waterway IN ('dam', 'weir', 'lock_gate', 'waterfall') AND (p.way && !bbox!)
                     AND l.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain')
                   ORDER BY p.osm_id, contructed_width DESC,
                     ST_LineLocatePoint(l.way, p.way) ASC -- this gives downstream waterways priority
                 ) AS plines
             ) AS plines2
          WHERE line IS NOT NULL
        ) AS water_barriers_line
    properties:
      minzoom: 11
  - id: water-barriers-line
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (-- All of this assumes a metric coordinate system, won't work with geographic coordinates
         -- This is the full complexity version of the water-barrier rendering which is relatively slow
         -- First query: barriers mapped using ways not intersecting a waterway
         SELECT
            way,
            waterway,
            'line' AS wtype
          FROM planet_osm_line b
          WHERE waterway IN ('dam', 'weir', 'lock_gate') AND (b.way && !bbox!)
          AND NOT EXISTS
            (SELECT 1 FROM planet_osm_line l WHERE ST_Intersects(b.way, l.way)
              AND l.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain'))
         UNION ALL
         -- Second query: barriers mapped using ways intersecting a waterway
         SELECT
            way,
            waterway,
            wtype
          FROM
          ( -- This aggregates all barrier ways intersecting at a common point
            WITH barriers_grouped AS
            (SELECT DISTINCT ON (osm_id)
                barrier,
                ST_LineSubstring(
                  line,
                  GREATEST(0.0, ST_LineLocatePoint(line, point)-1.0/ST_Length(line)),
                  LEAST(1.0, ST_LineLocatePoint(line, point)+1.0/ST_Length(line))) AS line,
                point,
                waterway,
                wtype,
                contructed_width,
                mapped_width,
                angle
              FROM
                (SELECT
                    MIN(b.osm_id) AS osm_id,
                    ST_LineMerge(ST_Collect(b.way)) AS barrier,
                    l.way AS line,
                    ST_PointOnSurface(ST_Intersection(ST_LineMerge(ST_Collect(b.way)), l.way)) AS point,
                    MIN(b.waterway) AS waterway,
                    MIN(l.waterway) AS wtype,
                    MAX(carto_waterway_line_width(l.waterway, z(!scale_denominator!)) +
                      (CASE WHEN l.waterway IN ('river', 'canal') THEN 0 ELSE 0.5 END)) *
                        NULLIF(!scale_denominator!*0.001*0.28,0) AS contructed_width,
                    SUM(ST_Length(b.way)) AS mapped_width,
                    (CASE WHEN MIN(b.waterway) = 'lock_gate' THEN pi()/2.3 ELSE pi()/2 END) AS angle
                  FROM planet_osm_line b
                  JOIN planet_osm_line l ON ST_Intersects(b.way, l.way)
                  WHERE b.waterway IN ('dam', 'weir', 'lock_gate') AND (b.way && !bbox!)
                    AND l.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain')
                  GROUP BY ST_Intersection(b.way, l.way), l.way
                ) AS barriers
                ORDER BY osm_id, contructed_width DESC,
                  ST_LineLocatePoint(line, point) ASC -- this gives downstream waterways priority
            ) -- end barriers_grouped
            -- directly render the way if the mapped size is larger than the contrcted alternative (high zoom)
            SELECT
                barrier AS way,
                waterway,
                wtype
              FROM barriers_grouped WHERE contructed_width <= mapped_width
            UNION ALL
            -- render the barrier line contructed from intersection point (low zoom)
            SELECT
                ST_MakeLine(ARRAY[
                  ST_Rotate(
                    ST_SetSRID(ST_MakePoint(
                    ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line),
                    ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line)
                  ), 3857), -angle, point),
                  point,
                  ST_Rotate(
                    ST_SetSRID(ST_MakePoint(
                    ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line),
                    ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line)
                  ), 3857), angle, point)
                ]) AS way,
                waterway,
                wtype
              FROM barriers_grouped WHERE contructed_width > mapped_width
          ) AS blines
         UNION ALL
         -- Third query: barriers mapped using polygons not intersecting a waterway
         SELECT
            way,
            waterway,
            'polygon' AS wtype
          FROM planet_osm_polygon b
          WHERE waterway IN ('dam', 'weir', 'lock_gate') AND (b.way && !bbox!)
          AND NOT EXISTS
            (SELECT 1 FROM planet_osm_line l WHERE ST_Intersects(b.way, l.way)
              AND l.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain'))
         UNION ALL
         -- Fourth query: barriers mapped using polygons intersecting a waterway
         SELECT
            way,
            waterway,
            wtype
          FROM
          (
            WITH barriers_grouped AS
            (SELECT DISTINCT ON (osm_id)
                osm_id,
                barrier,
                waterarea,
                ST_LineSubstring(
                  line,
                  GREATEST(0.0, ST_LineLocatePoint(line, point)-1.0/ST_Length(line)),
                  LEAST(1.0, ST_LineLocatePoint(line, point)+1.0/ST_Length(line))) AS line,
                line AS line_orig,
                point,
                waterway,
                wtype,
                contructed_width,
                -- ST_Length(ST_Intersection(ST_Boundary(barrier), waterarea)) AS linear_width,
                polygon_width,
                angle
              FROM
                (SELECT
                    MIN(b.osm_id) AS osm_id,
                    ST_Collect(b.way) AS barrier,
                    (SELECT
                        ST_Union(w.way)
                      FROM planet_osm_polygon w
                      WHERE
                        (w.waterway IN ('dock', 'riverbank')
                          OR w.landuse IN ('reservoir', 'basin')
                          OR w."natural" IN ('water', 'glacier'))
                        AND w.building IS NULL
                        AND ST_Intersects(w.way, ST_Collect(b.way))
                    ) AS waterarea,
                    l.way AS line,
                    (ST_Dump(ST_Intersection(ST_Boundary(b.way), l.way))).geom AS point,
                    MIN(b.waterway) AS waterway,
                    MIN(l.waterway) AS wtype,
                    MAX(carto_waterway_line_width(l.waterway, z(!scale_denominator!)) +
                      (CASE WHEN l.waterway IN ('river', 'canal') THEN 0 ELSE 0.5 END)) *
                        NULLIF(!scale_denominator!*0.001*0.28,0) AS contructed_width,
                    MAX(ST_Length(ST_BoundingDiagonal(b.way))) AS polygon_width,
                    (CASE WHEN MIN(b.waterway) = 'lock_gate' THEN pi()/2.3 ELSE pi()/2 END) AS angle
                  FROM planet_osm_polygon b
                  JOIN planet_osm_line l ON ST_Intersects(ST_Boundary(b.way), l.way)
                  WHERE b.waterway IN ('dam') AND (b.way && !bbox!)
                    AND l.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain')
                  GROUP BY ST_Intersection(ST_Boundary(b.way), l.way), l.way
                ) AS barriers
                ORDER BY osm_id, contructed_width DESC,
                  ST_LineLocatePoint(line, point) ASC
            ) -- end barriers_grouped
            -- large enough polygon - render directly
            SELECT
                barrier AS way,
                waterway,
                'polygon' AS wtype
              FROM barriers_grouped
              WHERE polygon_width >= 2.5*contructed_width
            UNION ALL
            -- has intersecting water areas and medium size polygon - render linear representation
            (SELECT DISTINCT ON (osm_id)
                way,
                waterway,
                wtype
              FROM
                (SELECT
                    osm_id,
                    (ST_Dump(ST_CollectionExtract(ST_Intersection(way, line_orig), 1))).geom AS point,
                    line_orig,
                    way,
                    waterway,
                    wtype
                  FROM
                    (SELECT
                        osm_id,
                        (ST_Dump(ST_CollectionExtract(ST_Intersection(ST_Boundary(barrier), waterarea), 2))).geom AS way,
                        line_orig,
                        waterway,
                        wtype
                      FROM barriers_grouped
                      WHERE (waterarea IS NOT NULL AND polygon_width < 2.5*contructed_width AND polygon_width >= contructed_width)
                    ) AS bparts
                ) AS bparts2
              -- this selects the first part of the intersection between barrier polygon and water area
              -- in waterway direction
              ORDER BY osm_id, ST_LineLocatePoint(line_orig, point) ASC)
            UNION ALL
            -- no intersecting water areas and polygon medium or small - treat as node
            -- has intersecting water areas and polygon small - treat as node
            SELECT
                ST_MakeLine(ARRAY[
                  ST_Rotate(
                    ST_SetSRID(ST_MakePoint(
                    ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line),
                    ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line)
                  ), 3857), -angle, point),
                  point,
                  ST_Rotate(
                    ST_SetSRID(ST_MakePoint(
                    ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line),
                    ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line)
                  ), 3857), angle, point)
                ]) AS way,
                waterway,
                wtype
              FROM barriers_grouped
                WHERE (waterarea IS NULL AND polygon_width < 2.5*contructed_width)
                  OR (waterarea IS NOT NULL AND polygon_width < contructed_width)
          ) AS bpolys
         UNION ALL
         -- Fifth query: barriers mapped using nodes on a waterway
         SELECT
             ST_MakeLine(ARRAY[
               ST_Rotate(
                 ST_SetSRID(ST_MakePoint(
                 ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line),
                 ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line)
               ), 3857), -angle, point),
               point,
               ST_Rotate(
                 ST_SetSRID(ST_MakePoint(
                 ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line),
                 ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*0.5/ST_Length(line)
               ), 3857), angle, point)
             ]) AS way,
             waterway,
             wtype
           FROM
             -- outer query: points with either nominal contructed waterway width or riverbank width
             (SELECT
                 point,
                 line,
                 waterway,
                 wtype,
                 GREATEST(
                   contructed_width,
                   -- this selects only the center part of the multilinestring returned
                   -- by the inner select (in case of large and complex water polygons)
                   (SELECT
                       ST_Length(geom)
                     FROM
                       -- this selects the part of a line orthogonal to the waterway
                       -- ten times the nominal contructed waterway width that intersects
                       -- the water polygon intersecting the barrier point
                       (SELECT
                           (ST_Dump(ST_Intersection(
                             ST_Union(poly.way),
                             ST_MakeLine(ARRAY[
                               ST_Rotate(
                                 ST_SetSRID(ST_MakePoint(
                                 ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*5/ST_Length(line),
                                 ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*5/ST_Length(line)
                               ), 3857), -pi()/2, point),
                               ST_Rotate(
                                 ST_SetSRID(ST_MakePoint(
                                 ST_X(point)+(ST_X(ST_EndPoint(line))-ST_X(ST_StartPoint(line)))*contructed_width*5/ST_Length(line),
                                 ST_Y(point)+(ST_Y(ST_EndPoint(line))-ST_Y(ST_StartPoint(line)))*contructed_width*5/ST_Length(line)
                               ), 3857), pi()/2, point)
                             ])))).geom AS geom
                         FROM planet_osm_polygon poly
                         WHERE (waterway IN ('dock', 'riverbank') OR landuse IN ('reservoir', 'basin') OR "natural" IN ('water'))
                           AND ST_Intersects(poly.way, point) AND (poly.way && !bbox!)
                       ) AS line_segments
                     WHERE ST_DWithin(geom, point, 0.1) ORDER BY ST_Length(geom) DESC LIMIT 1
                   )
                 ) AS contructed_width,
                 angle
               FROM
                 -- inner query: points with nominal contructed waterway width
                 (SELECT DISTINCT ON (p.osm_id)
                     p.way AS point,
                     ST_LineSubstring(
                       l.way,
                       GREATEST(0.0, ST_LineLocatePoint(l.way, p.way)-1.0/ST_Length(l.way)),
                       LEAST(1.0, ST_LineLocatePoint(l.way, p.way)+1.0/ST_Length(l.way))) AS line,
                     p.waterway AS waterway,
                     l.waterway AS wtype,
                     (carto_waterway_line_width(l.waterway, z(!scale_denominator!)) +
                       (CASE WHEN p.waterway =  'waterfall' THEN 2 ELSE 0 END) +
                       (CASE WHEN l.waterway IN ('river', 'canal') THEN 0 ELSE 0.5 END)) *
                         NULLIF(!scale_denominator!*0.001*0.28,0) AS contructed_width,
                     (CASE WHEN p.waterway =  'lock_gate' THEN pi()/2.3 ELSE pi()/2 END) AS angle
                   FROM planet_osm_point p
                   JOIN planet_osm_line l ON ST_DWithin(p.way, l.way, 0.1)
                   WHERE p.waterway IN ('dam', 'weir', 'lock_gate', 'waterfall') AND (p.way && !bbox!)
                     AND l.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain')
                   ORDER BY p.osm_id, contructed_width DESC,
                     ST_LineLocatePoint(l.way, p.way) ASC -- this gives downstream waterways priority
                 ) AS plines
             ) AS plines2
          WHERE line IS NOT NULL
        ) AS water_barriers_line
    properties:
      minzoom: 11
  - id: springs-connected
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
          ST_Difference(ST_Buffer(point, (0.5*width + 1.0*(CASE WHEN width > 4.2 THEN 1.5 ELSE 1 END))*NULLIF(!scale_denominator!*0.001*0.28,0)), ST_Buffer(line, 0.5*width*NULLIF(!scale_denominator!*0.001*0.28,0))) AS way
          FROM ( -- subselect to avoid duplicating the line width
            SELECT
              p.way AS point,
              l.way AS line,
              carto_waterway_line_width(l.waterway, z(!scale_denominator!)) + 1.5 AS width
            FROM planet_osm_point p
            JOIN planet_osm_line l ON ST_DWithin(p.way, l.way, 0.1)
            WHERE p.natural IN ('spring', 'hot_spring') AND (p.way && !bbox!)
              AND l.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain')
            ) AS features
        ) AS springs
    properties:
      minzoom: 14
  - id: piers-poly
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way, man_made
          FROM planet_osm_polygon
          WHERE man_made IN ('pier', 'breakwater', 'groyne')
        ) AS piers_poly
    properties:
      minzoom: 12
  - id: piers-line
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way, man_made
          FROM planet_osm_line
          WHERE man_made IN ('pier', 'breakwater', 'groyne')
        ) AS piers_line
    properties:
      minzoom: 12
  - id: bridge
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels,
            man_made
          FROM planet_osm_polygon
          WHERE man_made = 'bridge'
        ) AS bridge
    properties:
      minzoom: 12
  - id: buildings
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            building
          FROM planet_osm_polygon
          WHERE building IS NOT NULL
            AND building != 'no'
            AND way_area > 0.01*!pixel_width!::real*!pixel_height!::real
          ORDER BY COALESCE(layer,0), way_area DESC
        ) AS buildings
    properties:
      minzoom: 13
  - id: landuse-overlay-lz
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            ('landuse_' || landuse) AS feature,
            -- we use width for way_pixels here so it is identical to the column name 
            -- used in the roads layer where the higher zoom levels are rendered
            way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS width
          FROM planet_osm_polygon
          WHERE landuse = 'military'
            AND building IS NULL
        ) AS landuse_overlay
    properties:
      minzoom: 7
      maxzoom: 9
  - id: ferry-routes-lz
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM planet_osm_line
          WHERE route = 'ferry'
        ) AS ferry_routes
    properties:
      minzoom: 7
      maxzoom: 9
  - id: roads-low-zoom
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      geometry_table: planet_osm_roads
      table: |-
        (SELECT
            way,
            road_layer,
            feature,
            int_surface,
            int_tunnel,
            int_bridge,
            link,
            width_nominal,
            width
          FROM
            (WITH roads_all AS
              (SELECT
                  way,
                  COALESCE(
                    ('highway_' || (CASE WHEN substr(highway, length(highway)-4, 5) = '_link' THEN substr(highway, 0, length(highway)-4) ELSE highway end)),
                    ('railway_' || (CASE WHEN (railway = 'rail' AND service IN ('spur', 'siding', 'yard')) THEN 'INT-spur-siding-yard' 
                                         WHEN railway IN ('rail', 'tram', 'light_rail', 'funicular', 'narrow_gauge') THEN railway ELSE NULL END))
                  ) AS feature,
                  CASE WHEN surface IN ('unpaved', 'compacted', 'dirt', 'earth', 'fine_gravel', 'grass', 'grass_paver', 'gravel', 'ground',
                                        'mud', 'pebblestone', 'salt', 'sand', 'woodchips', 'clay') THEN 'unpaved'
                    WHEN surface IN ('paved', 'asphalt', 'cobblestone', 'cobblestone:flattened', 'sett', 'concrete', 'concrete:lanes',
                                        'concrete:plates', 'paving_stones', 'metal', 'wood') THEN 'paved'
                    ELSE NULL
                  END AS int_surface,
                  CASE WHEN tunnel = 'yes' OR tunnel = 'building_passage' OR covered = 'yes' THEN 'yes' ELSE 'no' END AS int_tunnel,
                  CASE WHEN bridge IN ('yes', 'boardwalk', 'cantilever', 'covered', 'low_water_crossing', 'movable', 'trestle', 'viaduct') THEN 'yes' ELSE 'no' END AS int_bridge,
                  CASE WHEN substr(highway, length(highway)-4, 5) = '_link' THEN 'yes' ELSE 'no' END AS link,
                  carto_highway_line_width(COALESCE(highway, railway), z(!scale_denominator!)) AS width_nominal,
                  z_order,
                  osm_id
                FROM planet_osm_roads
                WHERE highway IS NOT NULL
                  OR (railway IS NOT NULL AND railway != 'preserved'
                    AND (service IS NULL OR service NOT IN ('spur', 'siding', 'yard'))))
              SELECT
                  way,
                  'casing' AS road_layer,
                  feature,
                  int_surface,
                  int_tunnel,
                  int_bridge,
                  link,
                  width_nominal,
                  0.0 AS width,
                  0.0 AS casing_width,
                  z_order,
                  osm_id
                FROM roads_all
              UNION ALL
              SELECT
                  way,
                  'fill' AS road_layer,
                  feature,
                  int_surface,
                  int_tunnel,
                  int_bridge,
                  link,
                  width_nominal,
                  0.0 AS width,
                  0.0 AS casing_width,
                  z_order,
                  osm_id
                FROM roads_all) AS features
          ORDER BY
            z_order,
            osm_id
        ) AS roads_low_zoom
    properties:
      minzoom: 5
      maxzoom: 9
  - id: roads
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      geometry_table: planet_osm_line
      # This is one of the most complex layers, so it bears explaining in some detail
      # It is necessary to
      # - Have roads and railways in the same layer to get ordering right
      # - Return two linestrings for ways which are both a road and railway
      # - Compute z_order here, rather than rely on osm2pgsql z_order
      table: |-
        (SELECT
            way,
            road_layer,
            feature,
            path_type,
            intermittent,
            seasonal,
            int_surface,
            int_tunnel,
            int_bridge,
            int_lane_right,
            int_lane_left,
            int_lanes,
            int_access,
            construction,
            service,
            link,
            tc_type,
            width_nominal,
            width_max,
            width,
            casing_width
          FROM ( -- this wraps all the different road sublayers, most of which are mostly sourced from the same CTEs (roads_all, road_areas_all, tc_all)
            WITH roads_all AS -- roads_all is based on the classic roads-casing/roads-fill/bridges layers + junction polygons
            (SELECT
                way,
                (CASE WHEN substr(feature, length(feature)-4, 5) = '_link' THEN substr(feature, 0, length(feature)-4) ELSE feature END) AS feature,
                path_type,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_junction,
                int_access,
                construction,
                service,
                link,
                width_nominal,
                GREATEST(width_nominal, width_tagged) AS width_max,
                CASE WHEN (width_tagged > width_nominal) THEN width_tagged ELSE 0.0 END AS width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM ( -- begin "features" subselect that contains both roads and rail/aero
                WITH highways_raw AS
                -- this queries all roads from the database together with the corresponding width values
                -- to be used both directly and for the sidewalk geometries
                (SELECT
                    way,
                    ('highway_' || highway) AS feature, -- only motorway to tertiary links are accepted later on
                    highway,
                    carto_path_type(foot, bicycle, horse) AS path_type,
                    CASE
                      WHEN surface IN ('unpaved', 'compacted', 'dirt', 'earth', 'fine_gravel', 'grass', 'grass_paver', 'gravel', 'ground',
                                       'mud', 'pebblestone', 'salt', 'sand', 'woodchips', 'clay') THEN 'unpaved'::text
                      WHEN surface IN ('paved', 'asphalt', 'cobblestone', 'cobblestone:flattened', 'sett', 'concrete', 'concrete:lanes',
                                       'concrete:plates', 'paving_stones', 'metal', 'wood') THEN 'paved'::text
                      ELSE NULL
                    END AS int_surface,
                    CASE
                      WHEN (tunnel IN ('yes', 'building_passage', 'avalanche_protector') OR covered = 'yes') THEN 'yes'::text
                      WHEN (covered = 'yes') THEN 'yes'::text
                      ELSE 'no'::text
                    END AS int_tunnel,
                    CASE
                      WHEN (bridge IN ('yes', 'boardwalk', 'cantilever', 'covered', 'low_water_crossing', 'movable', 'trestle', 'viaduct')) THEN 'yes'::text
                      WHEN (tags @> 'ford=>yes' OR tags @> 'ford=>stepping_stones') THEN 'ford'::text
                      ELSE 'no'::text
                    END AS int_bridge,
                    CASE WHEN (tags->'cycleway') IN ('lane') OR (tags->'cycleway:right') IN ('lane') THEN 'cycle'::text ELSE NULL END AS int_lane_right,
                    CASE WHEN (tags->'cycleway') IN ('lane') OR (tags->'cycleway:left') IN ('lane') THEN 'cycle'::text ELSE NULL END AS int_lane_left,
                    CASE
                      WHEN highway IN ('steps') THEN
                        CASE
                          WHEN (tags @> 'ramp:bicycle=>yes') THEN 'ramp_bicycle'::text
                          WHEN (tags @> 'ramp:stroller=>yes') THEN 'ramp_stroller'::text
                          WHEN (tags @> 'ramp:wheelchair=>yes') THEN 'ramp_wheelchair'::text
                          WHEN (tags @> 'handrail:center=>yes') THEN 'handrail'::text
                        ELSE ''::text END
                      WHEN (tags->'lanes') IN ('1', '2', '3', '4', '5', '6') THEN (tags->'lanes')::text
                      ELSE
                        CASE
                          WHEN highway IN ('motorway', 'trunk') THEN '2'::text
                          WHEN (oneway IS NULL OR NOT (oneway IN ('no', 'reversible'))) THEN '1'::text
                          WHEN highway IN ('residential', 'tertiary', 'secondary', 'primary') THEN '2'::text
                          ELSE '1'::text
                        END
                    END ||
                    CASE WHEN (tags @> 'lane_markings=>no') THEN 'u'::text ELSE ''::text END AS int_lanes,
                    CASE
                      WHEN (tags->'sidewalk') IN ('yes', 'both', 'right') OR (tags->'sidewalk:right') IN ('yes') THEN 
                        CASE WHEN (tags->'cycleway') IN ('track') OR (tags->'cycleway:right') IN ('track') THEN 'both'::text ELSE 'foot'::text END
                      ELSE
                        CASE WHEN (tags->'cycleway') IN ('track') OR (tags->'cycleway:right') IN ('track') THEN 'cycle'::text
                        ELSE
                          CASE WHEN (tags->'handrail') IN ('yes') OR (tags->'handrail:right') IN ('yes') THEN 'handrail'::text
                          ELSE
                            NULL
                          END
                        END
                    END AS int_side_right,
                    CASE
                      WHEN (tags->'sidewalk') IN ('yes', 'both', 'left') OR (tags->'sidewalk:left') IN ('yes') THEN 
                        CASE WHEN (tags->'cycleway') IN ('track') OR (tags->'cycleway:left') IN ('track') THEN 'both'::text ELSE 'foot'::text END
                      ELSE
                        CASE WHEN (tags->'cycleway') IN ('track') OR (tags->'cycleway:left') IN ('track') THEN 'cycle'::text
                        ELSE
                          CASE WHEN (tags->'handrail') IN ('yes') OR (tags->'handrail:left') IN ('yes') THEN 'handrail'::text
                          ELSE
                            NULL
                          END
                        END
                    END AS int_side_left,
                    carto_road_access(highway, access, tags->'vehicle', tags->'motor_vehicle', tags->'motorcar', bicycle, horse, foot, tags->'bus', tags->'psv') AS int_access,
                    construction,
                    CASE
                      WHEN service IN ('parking_aisle', 'drive-through', 'driveway') OR leisure IN ('slipway') THEN 'INT-minor'::text
                      ELSE 'INT-normal'::text
                    END AS service,
                    CASE
                      WHEN substr(highway, length(highway)-4, 5) = '_link' THEN 'yes'
                      ELSE 'no'
                    END AS link,
                    carto_highway_line_width(highway, service, z(!scale_denominator!)) AS width_nominal,
                    carto_highway_line_width_mapped(highway, tags->'width', tags->'lanes', !bbox!, !scale_denominator!) AS width_tagged,
                    COALESCE(layer,0) AS layernotnull,
                    osm_id,
                    z_order
                  FROM planet_osm_line
                  WHERE highway IS NOT NULL AND way && !bbox!
                ), -- end highways_raw CTE
                junctions AS
                (SELECT
                    -- for clipping away sidewalks not to be rendered
                    ST_Difference(junction_poly, junction_cut) AS clip,
                    -- for trimming the road line
                    bounds,
                    -- the remaining component to be rendered, clipped with extended bounds
                    CASE
                      WHEN feature in ('highway_steps') THEN ST_Buffer(ST_Intersection(junction_cut, bounds_ext), -casing_width)
                      ELSE ST_Intersection(junction_cut, bounds_ext)
                    END AS way,
                    feature,
                    path_type,
                    int_surface,
                    int_tunnel,
                    int_bridge,
                    int_lane_right,
                    int_lane_left,
                    int_lanes,
                    int_side_right,
                    int_side_left,
                    int_access,
                    construction,
                    service,
                    link,
                    width_nominal,
                    width_tagged,
                    casing_width,
                    layernotnull,
                    osm_id,
                    z_order
                  FROM
                    (SELECT
                        way,
                        -- the extended bounds to clip the junction polygon with
                        -- ST_Buffer(center, width_max*0.75*NULLIF(!scale_denominator!*0.001*0.28,0)) AS bounds_ext,
                        ST_Intersection(
                          COALESCE(
                            ST_Buffer(ways_other, width_max*0.75*NULLIF(!scale_denominator!*0.001*0.28,0)),
                            ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                          ),
                          ST_Buffer(center, width_max*1.5*NULLIF(!scale_denominator!*0.001*0.28,0))
                        ) AS bounds_ext,
                        -- the bounds to trim the road line for rendering
                        ST_Intersection(
                          COALESCE(
                            ST_Buffer(ways_other, width_max*0.5*NULLIF(!scale_denominator!*0.001*0.28,0)),
                            ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                          ),
                          ST_Buffer(center, width_max*NULLIF(!scale_denominator!*0.001*0.28,0))
                        ) AS bounds,
                        junction_poly,
                        -- cut the Multipolygon (if this is a junction that needs special processing)
                        -- into its components
                        (ST_Dump(junction_poly)).geom AS junction_cut,
                        feature,
                        path_type,
                        int_surface,
                        int_tunnel,
                        int_bridge,
                        int_lane_right,
                        int_lane_left,
                        int_lanes,
                        int_side_right,
                        int_side_left,
                        int_access,
                        construction,
                        service,
                        link,
                        width_nominal,
                        width_tagged,
                        width_max,
                        casing_width,
                        layernotnull,
                        osm_id,
                        z_order
                      FROM
                        (SELECT
                            center,
                            way,
                            (SELECT
                                -- all intersection roads
                                ST_Union(h2x.way)
                               FROM highways_raw h2x 
                               WHERE ST_DWithin(junctions_raw.center, h2x.way, 0.1)
                                 AND (junctions_raw.width_tagged > h2x.width_tagged)
                                 AND (junctions_raw.width_tagged > h2x.width_nominal)
                            ) AS ways_other,
                            -- the buffered way minus the buffered (more narrow) intersecting ways form the base of the junction polygon
                            ST_Difference(
                              ST_Buffer(way, (width_max - 2.0*casing_width)*0.5*NULLIF(!scale_denominator!*0.001*0.28,0)),
                              COALESCE(
                                (SELECT
                                    -- the cut is thinner than the buffered line to avoid agg rendering artefacts at the edge
                                    ST_Union(ST_Buffer(h2x.way, GREATEST(1.0, GREATEST(h2x.width_nominal, h2x.width_tagged)-1.5)*0.5*NULLIF(!scale_denominator!*0.001*0.28,0)))
                                  FROM highways_raw h2x 
                                  WHERE ST_DWithin(junctions_raw.center, h2x.way, 0.1)
                                    AND (junctions_raw.width_tagged > h2x.width_tagged)
                                    AND (junctions_raw.width_tagged > h2x.width_nominal)
                                ),
                                ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                              )
                            ) AS junction_poly,
                            ('highway_' || highway) AS feature,
                            path_type,
                            int_surface,
                            int_tunnel,
                            int_bridge,
                            int_lane_right,
                            int_lane_left,
                            int_lanes,
                            int_side_right,
                            int_side_left,
                            int_access,
                            construction,
                            service,
                            link,
                            width_nominal,
                            width_tagged,
                            width_max,
                            casing_width,
                            layernotnull,
                            osm_id,
                            z_order
                          FROM
                            (SELECT
                                ST_StartPoint(way) AS center,
                                way,
                                highway,
                                path_type,
                                int_surface,
                                int_tunnel,
                                int_bridge,
                                int_lane_right,
                                int_lane_left,
                                int_lanes,
                                int_side_right,
                                int_side_left,
                                int_access,
                                construction,
                                service,
                                link,
                                width_nominal,
                                width_tagged,
                                GREATEST(width_nominal, width_tagged) AS width_max,
                                carto_casing_line_width(highway, int_bridge, z(!scale_denominator!)) AS casing_width,
                                layernotnull,
                                osm_id,
                                z_order
                              FROM highways_raw h1
                              WHERE
                                -- either one way connecting not at the ends or two ways connecting at the ends
                                -- and no way connecting at end with the same highway class
                               (SELECT
                                   SUM(
                                     CASE
                                       WHEN (ST_DWithin(ST_StartPoint(h1.way), ST_StartPoint(h2.way), 0.1) OR
                                             ST_DWithin(ST_StartPoint(h1.way), ST_EndPoint(h2.way), 0.1)) THEN
                                         CASE
                                           WHEN (h1.highway = h2.highway) AND (h1.osm_id != h2.osm_id) THEN 3
                                           WHEN (h1.width_tagged > h2.width_tagged)
                                            AND (h1.width_tagged > h2.width_nominal) THEN 1
                                           ELSE 0
                                         END
                                       WHEN (h1.width_tagged > h2.width_tagged)
                                        AND (h1.width_tagged > h2.width_nominal) THEN 2
                                       ELSE 0
                                     END)
                                 FROM highways_raw h2 WHERE ST_DWithin(ST_StartPoint(h1.way), h2.way, 0.1)) = 2
                              UNION ALL
                              SELECT
                                ST_EndPoint(way) AS center,
                                way,
                                highway,
                                path_type,
                                int_surface,
                                int_tunnel,
                                int_bridge,
                                int_lane_right,
                                int_lane_left,
                                int_lanes,
                                int_side_right,
                                int_side_left,
                                int_access,
                                construction,
                                service,
                                link,
                                width_nominal,
                                width_tagged,
                                GREATEST(width_nominal, width_tagged) AS width_max,
                                carto_casing_line_width(highway, int_bridge, z(!scale_denominator!)) AS casing_width,
                                layernotnull,
                                osm_id,
                                z_order
                              FROM highways_raw h1
                              WHERE
                                -- either one way connecting not at the ends or two ways connecting at the ends
                                -- and no way connecting at end with the same highway class
                               (SELECT
                                   SUM(
                                     CASE
                                       WHEN (ST_DWithin(ST_EndPoint(h1.way), ST_StartPoint(h2.way), 0.1) OR
                                             ST_DWithin(ST_EndPoint(h1.way), ST_EndPoint(h2.way), 0.1)) THEN
                                         CASE
                                           WHEN (h1.highway = h2.highway) AND (h1.osm_id != h2.osm_id) THEN 3
                                           WHEN (h1.width_tagged > h2.width_tagged)
                                            AND (h1.width_tagged > h2.width_nominal) THEN 1
                                           ELSE 0
                                         END
                                       WHEN (h1.width_tagged > h2.width_tagged)
                                        AND (h1.width_tagged > h2.width_nominal) THEN 2
                                       ELSE 0
                                     END)
                                 FROM highways_raw h2 WHERE ST_DWithin(ST_EndPoint(h1.way), h2.way, 0.1)) = 2
                            ) AS junctions_raw
                          WHERE (width_tagged > width_nominal)
                            -- we simply assume that the previous conditions and the need to render junctions
                            -- are not met at z<14 - that simplifies mss code (because it is the same as for hw areas)
                            AND z(!scale_denominator!) >= 14
                        ) AS junctions2
                      WHERE ST_NumGeometries(junction_poly) > 1
                    ) AS junctions_flat
                  WHERE ST_Intersects(junction_cut, way)
                ), -- end junctions CTE
                highways_all AS
                (SELECT
                    ST_Difference(
                      h.way,
                      COALESCE(
                        j.bounds,
                        ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                      )
                    ) AS way,
                    h.way AS way_orig,
                    j.clip AS clip,
                    h.feature AS feature,
                    h.highway AS highway,
                    h.path_type AS path_type,
                    h.int_surface AS int_surface,
                    h.int_tunnel AS int_tunnel,
                    h.int_bridge AS int_bridge,
                    h.int_lane_right AS int_lane_right,
                    h.int_lane_left AS int_lane_left,
                    h.int_lanes AS int_lanes,
                    h.int_side_right AS int_side_right,
                    h.int_side_left AS int_side_left,
                    h.int_access AS int_access,
                    h.construction AS construction,
                    h.service AS service,
                    h.link AS link,
                    h.width_nominal AS width_nominal,
                    h.width_tagged AS width_tagged,
                    carto_casing_line_width(h.highway, h.int_bridge, z(!scale_denominator!)) AS casing_width,
                    h.layernotnull AS layernotnull,
                    h.osm_id AS osm_id,
                    h.z_order AS z_order
                  FROM highways_raw h
                  LEFT JOIN
                    (SELECT
                        ST_Union(bounds) AS bounds,
                        ST_Union(clip) AS clip,
                        osm_id
                      FROM junctions GROUP BY osm_id
                    ) AS j
                    ON j.osm_id = h.osm_id
                ), -- end highways_all CTE
                sidewalks_raw AS
                (SELECT
                    buffer,
                    -- this generates a buffer outline (either both or one sided)
                    -- for all rows with some kind of sidewalk
                    CASE
                      WHEN int_side_right IS NULL AND int_side_left IS NULL THEN
                        NULL
                      WHEN int_side_right IS NULL THEN
                        ST_Intersection(
                          ST_Boundary(buffer),
                          ST_Buffer(
                            ST_OffsetCurve(way, (0.5*width_max)*NULLIF(!scale_denominator!*0.001*0.28,0)),
                            (0.5*width_max + sw_offset)*NULLIF(!scale_denominator!*0.001*0.28,0)
                          )
                        )
                      WHEN int_side_left IS NULL THEN
                        ST_Intersection(
                          ST_Boundary(buffer),
                          ST_Buffer(
                            ST_OffsetCurve(way, -(0.5*width_max)*NULLIF(!scale_denominator!*0.001*0.28,0)),
                            (0.5*width_max + sw_offset)*NULLIF(!scale_denominator!*0.001*0.28,0)
                          )
                        )
                      ELSE ST_Boundary(buffer)
                    END AS line,
                    way,
                    way_orig,
                    feature,
                    path_type,
                    int_surface,
                    int_tunnel,
                    int_bridge,
                    int_access,
                    construction,
                    service,
                    link,
                    width_nominal,
                    width_tagged,
                    carto_casing_line_width('sidewalk', int_bridge, z(!scale_denominator!)) AS casing_width,
                    layernotnull,
                    osm_id,
                    z_order
                  FROM
                    (SELECT
                        -- this is the buffer that forms the basis for the sidewalk geometries and their clipping
                        ST_Difference(
                          ST_Buffer(
                            way_orig,
                            (0.5*width_max + sw_offset)*NULLIF(!scale_denominator!*0.001*0.28,0)
                          ),
                          COALESCE(
                            ST_Buffer(clip, (sw_offset + 1.0)*NULLIF(!scale_denominator!*0.001*0.28,0)),
                            ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                          )
                        ) AS buffer,
                        way,
                        way_orig,
                        ('highway_sidewalk_' || COALESCE(int_side_right,int_side_left)) AS feature,
                        path_type,
                        int_surface,
                        int_tunnel,
                        int_bridge,
                        int_side_right,
                        int_side_left,
                        int_access,
                        construction,
                        service,
                        link,
                        width_nominal,
                        width_tagged,
                        width_max,
                        sw_offset,
                        layernotnull,
                        osm_id,
                        z_order
                      FROM
                        -- roads_side are the roads with sidewalks
                        (WITH roads_side AS
                          (SELECT
                              way,
                              way_orig,
                              clip,
                              feature,
                              path_type,
                              int_surface,
                              int_tunnel,
                              int_bridge,
                              int_side_right,
                              int_side_left,
                              int_access,
                              construction,
                              highway AS service, -- we use this to store the original highway value to be able to use that in MSS code
                              link,
                              width_nominal,
                              width_tagged,
                              GREATEST(width_nominal, width_tagged) AS width_max,
                              carto_casing_line_width(highway, int_bridge, z(!scale_denominator!)) AS casing_width,
                              layernotnull,
                              osm_id,
                              z_order
                            FROM highways_all
                            WHERE (int_side_right IS NOT NULL OR int_side_left IS NOT NULL)
                              AND width_nominal > 0.0
                              AND z(!scale_denominator!) >= 18
                          )
                        -- this are the roads with either just one or two identical sidewalks
                        SELECT
                            way,
                            way_orig,
                            clip,
                            feature,
                            path_type,
                            int_surface,
                            int_tunnel,
                            int_bridge,
                            int_side_right,
                            int_side_left,
                            int_access,
                            construction,
                            service,
                            link,
                            width_nominal,
                            width_tagged,
                            width_max,
                            casing_width,
                            CASE WHEN int_bridge = 'no' THEN 3.0 ELSE 2.5 END * casing_width AS sw_offset,
                            layernotnull,
                            osm_id,
                            z_order
                          FROM roads_side
                          WHERE (int_side_right = int_side_left OR int_side_right IS NULL OR int_side_left IS NULL)
                        UNION ALL
                        -- this are (separately) the roads with two different sidewalks
                        SELECT
                            way,
                            way_orig,
                            clip,
                            feature,
                            path_type,
                            int_surface,
                            int_tunnel,
                            int_bridge,
                            int_side_right,
                            NULL AS int_side_left,
                            int_access,
                            construction,
                            service,
                            link,
                            width_nominal,
                            width_tagged,
                            width_max,
                            casing_width,
                            CASE WHEN int_bridge = 'no' THEN 3.0 ELSE 2.5 END * casing_width AS sw_offset,
                            layernotnull,
                            osm_id,
                            z_order
                          FROM roads_side
                          WHERE NOT(int_side_right = int_side_left OR int_side_right IS NULL OR int_side_left IS NULL)
                        UNION ALL
                        SELECT
                            way,
                            way_orig,
                            clip,
                            feature,
                            path_type,
                            int_surface,
                            int_tunnel,
                            int_bridge,
                            NULL AS int_side_right,
                            int_side_left,
                            int_access,
                            construction,
                            service,
                            link,
                            width_nominal,
                            width_tagged,
                            width_max,
                            casing_width,
                            CASE WHEN int_bridge = 'no' THEN 3.0 ELSE 2.5 END * casing_width AS sw_offset,
                            layernotnull,
                            osm_id,
                            z_order
                          FROM roads_side
                          WHERE NOT(int_side_right = int_side_left OR int_side_right IS NULL OR int_side_left IS NULL)
                        UNION ALL
                        -- this are all other roads without sidewalks the sidewalks need to be clipped with
                        SELECT
                            way,
                            way_orig,
                            clip,
                            feature,
                            path_type,
                            int_surface,
                            int_tunnel,
                            int_bridge,
                            NULL AS int_side_right,
                            NULL AS int_side_left,
                            int_access,
                            construction,
                            service,
                            link,
                            width_nominal,
                            width_tagged,
                            GREATEST(width_nominal, width_tagged) AS width_max,
                            carto_casing_line_width(highway, int_bridge, z(!scale_denominator!)) AS casing_width,
                            3.0 * carto_casing_line_width(highway, int_bridge, z(!scale_denominator!)) AS sw_offset,
                            layernotnull,
                            osm_id,
                            z_order
                          FROM highways_all
                          WHERE (int_side_right IS NULL AND int_side_left IS NULL)
                            AND width_nominal > 0.0
                            AND z(!scale_denominator!) >= 18
                        ) AS sidewalks
                    ) AS l -- end of sidewalks select
                ) -- end sidewalks_raw CTE
                SELECT -- begin of sidewalks select
                    ST_Difference(
                      ST_Difference(
                        line,
                        -- this clips the sidewalk outlines with all adjacent roads
                        (SELECT
                            COALESCE(
                              ST_Union(buffer),
                              ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                            )
                          FROM sidewalks_raw o
                          WHERE
                            -- intersect at ends or in equal layer
                            ((ST_DWithin(l.way_orig, o.way_orig, 0.1) AND
                              (o.layernotnull = l.layernotnull OR (l.int_bridge = 'no' AND l.int_tunnel = 'no')) AND
                              o.int_bridge = l.int_bridge AND
                              o.int_tunnel = l.int_tunnel) OR
                             ST_DWithin(
                               ST_Collect(ST_StartPoint(l.way_orig), ST_EndPoint(l.way_orig)),
                               ST_Collect(ST_StartPoint(o.way_orig), ST_EndPoint(o.way_orig)), 0.1)
                            )
                            AND o.osm_id != l.osm_id
                        )
                      ),
                      -- this clips the sidewalk outlines with a possible junction clip polygon
                      (SELECT
                          COALESCE(
                            ST_Union(ST_Buffer(j.clip, 6.0*GREATEST(j.casing_width, l.casing_width)*NULLIF(!scale_denominator!*0.001*0.28,0))),
                            ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                          )
                        FROM junctions j
                        WHERE
                          j.int_bridge = l.int_bridge AND
                          j.int_tunnel = l.int_tunnel AND
                          j.osm_id = l.osm_id
                      )
                    ) AS way,
                    feature,
                    path_type,
                    int_surface,
                    int_tunnel,
                    int_bridge,
                    'null' AS int_lane_right,
                    'null' AS int_lane_left,
                    NULL AS int_lanes,
                    'no' AS int_junction,
                    int_access,
                    construction,
                    service,
                    link,
                    width_nominal,
                    width_tagged,
                    casing_width,
                    layernotnull,
                    osm_id,
                    z_order
                  FROM sidewalks_raw l
                  WHERE line IS NOT NULL
                    AND int_tunnel = 'no'
                  -- end of sidewalks select
                UNION ALL
                SELECT -- begin of main road select
                    way,
                    feature,
                    path_type,
                    int_surface,
                    int_tunnel,
                    int_bridge,
                    int_lane_right,
                    int_lane_left,
                    int_lanes,
                    'no' AS int_junction,
                    int_access,
                    construction,
                    service,
                    link,
                    width_nominal,
                    width_tagged,
                    casing_width,
                    layernotnull,
                    osm_id,
                    z_order
                  FROM highways_all
                  -- end of main road select
                UNION ALL
                SELECT -- begin of junction polygons select
                    way,
                    feature,
                    path_type,
                    int_surface,
                    int_tunnel,
                    int_bridge,
                    int_lane_right,
                    int_lane_left,
                    int_lanes,
                    'yes' AS int_junction,
                    int_access,
                    construction,
                    service,
                    link,
                    width_nominal,
                    width_tagged,
                    casing_width,
                    layernotnull,
                    osm_id,
                    z_order
                  FROM junctions
                  -- end of junction polygons select
                UNION ALL
                SELECT -- begin of ford/mountain_pass point pseudo-line select
                    ST_LineSubstring(way, GREATEST(0, position-length*0.5*pass_length), LEAST(1, position+length*0.5*pass_length)) AS way,
                    feature,
                    path_type,
                    int_surface,
                    int_tunnel,
                    int_bridge,
                    'null' AS int_lane_right,
                    'null' AS int_lane_left,
                    NULL AS int_lanes,
                    'no' AS int_junction,
                    int_access,
                    construction,
                    service,
                    link,
                    width_nominal,
                    width_tagged,
                    carto_casing_line_width(highway, int_bridge, z(!scale_denominator!)) AS casing_width,
                    layernotnull,
                    osm_id,
                    z_order
                    FROM
                      (SELECT
                          l.way AS way, -- this is the highway intersecting the ford node
                          ST_LineLocatePoint(l.way, p.way) AS position, -- this is the position along the way
                          NULLIF(!scale_denominator!*0.001*0.28,0)/ST_Length(l.way) AS length, -- this is the pixel size as a fraction of the way length
                          CASE WHEN (p.tags @> 'mountain_pass=>yes') THEN GREATEST(7, carto_highway_line_width(
                            l.highway, l.service, z(!scale_denominator!))) ELSE 5 END AS pass_length,
                          ('highway_' || l.highway) AS feature,
                          l.highway AS highway,
                          carto_path_type(l.foot, l.bicycle, l.horse) AS path_type,
                          CASE
                            WHEN surface IN ('unpaved', 'compacted', 'dirt', 'earth', 'fine_gravel', 'grass', 'grass_paver', 'gravel', 'ground',
                                             'mud', 'pebblestone', 'salt', 'sand', 'woodchips', 'clay') THEN 'unpaved'::text
                            WHEN surface IN ('paved', 'asphalt', 'cobblestone', 'cobblestone:flattened', 'sett', 'concrete', 'concrete:lanes',
                                             'concrete:plates', 'paving_stones', 'metal', 'wood') THEN 'paved'::text
                            ELSE NULL
                          END AS int_surface,
                          CASE
                            WHEN (tunnel IN ('yes', 'building_passage', 'avalanche_protector') OR covered = 'yes') THEN 'yes'::text
                            WHEN (covered = 'yes') THEN 'yes'::text
                            ELSE 'no'::text
                          END AS int_tunnel,
                          CASE WHEN (p.tags @> 'mountain_pass=>yes') THEN 'mountain_pass' ELSE 'ford_node' END AS int_bridge,
                          carto_road_access(l.highway, l.access, l.tags->'vehicle', l.tags->'motor_vehicle', l.tags->'motorcar', l.bicycle, l.horse, l.foot, l.tags->'bus', l.tags->'psv') AS int_access,
                          l.construction AS construction,
                          CASE
                            WHEN l.service IN ('parking_aisle', 'drive-through', 'driveway') THEN 'INT-minor'::text
                            ELSE 'INT-normal'::text
                          END AS service,
                          CASE
                            WHEN substr(l.highway, length(l.highway)-4, 5) = '_link' THEN 'yes'
                            ELSE 'no'
                          END AS link,
                          carto_highway_line_width(l.highway, l.service, z(!scale_denominator!)) AS width_nominal,
                          carto_highway_line_width_mapped(l.highway, l.tags->'width', l.tags->'lanes', !bbox!, !scale_denominator!) AS width_tagged,
                          COALESCE(l.layer,0) AS layernotnull,
                          l.osm_id AS osm_id,
                          l.z_order AS z_order
                        FROM planet_osm_point p
                          JOIN planet_osm_line l ON ST_DWithin(p.way, l.way, 0.1) -- Assumes Mercator
                        WHERE (p.tags @> 'ford=>yes' OR p.tags @> 'ford=>stepping_stones' OR p.tags @> 'mountain_pass=>yes')
                          AND l.highway IS NOT NULL
                          AND p.way && !bbox!
                      ) AS fords
                  -- end of ford/mountain_pass point pseudo-line select
                UNION ALL
                SELECT -- begin of rail/aero select
                    way,
                    COALESCE(
                      ('railway_' || (CASE WHEN railway = 'preserved' AND service IN ('spur', 'siding', 'yard') THEN 'INT-preserved-ssy'::text 
                                           WHEN (railway = 'rail' AND service IN ('spur', 'siding', 'yard')) THEN 'INT-spur-siding-yard'  
                                           WHEN (railway = 'tram' AND service IN ('spur', 'siding', 'yard')) THEN 'tram-service' ELSE railway END)),
                      ('aeroway_' || aeroway)
                    ) AS feature,
                    'null' AS path_type,
                    CASE
                      WHEN surface IN ('unpaved', 'compacted', 'dirt', 'earth', 'fine_gravel', 'grass', 'grass_paver', 'gravel', 'ground',
                                       'mud', 'pebblestone', 'salt', 'sand', 'woodchips', 'clay') THEN 'unpaved'::text
                      WHEN surface IN ('paved', 'asphalt', 'cobblestone', 'cobblestone:flattened', 'sett', 'concrete', 'concrete:lanes',
                                       'concrete:plates', 'paving_stones', 'metal', 'wood') THEN 'paved'::text
                      ELSE NULL
                    END AS int_surface,
                    CASE
                      WHEN (tunnel IN ('yes', 'building_passage', 'avalanche_protector') OR covered = 'yes') THEN 'yes'::text
                      WHEN (covered = 'yes') THEN 'yes'::text
                      ELSE 'no'::text
                    END AS int_tunnel,
                    CASE
                      WHEN (bridge IN ('yes', 'boardwalk', 'cantilever', 'covered', 'low_water_crossing', 'movable', 'trestle', 'viaduct')) THEN 'yes'::text
                      WHEN (tags @> 'ford=>yes' OR tags @> 'ford=>stepping_stones') THEN 'ford'::text
                      ELSE 'no'::text
                    END AS int_bridge,
                    'null' AS int_lane_right,
                    'null' AS int_lane_left,
                    NULL AS int_lanes,
                    'no' AS int_junction,
                    NULL AS int_access,
                    construction,
                    CASE
                      WHEN service IN ('parking_aisle', 'drive-through', 'driveway') OR leisure IN ('slipway') THEN 'INT-minor'::text
                      ELSE 'INT-normal'::text
                    END AS service,
                    'no' AS link,
                    carto_highway_line_width(COALESCE(railway, aeroway), z(!scale_denominator!)) AS width_nominal,
                    CASE
                      WHEN aeroway IS NOT NULL THEN
                        carto_aeroway_line_width_mapped(aeroway, tags->'width', way, !bbox!, !scale_denominator!)
                      ELSE
                        carto_highway_line_width_mapped(railway, tags->'width', tags->'lanes', !bbox!, !scale_denominator!)
                    END AS width_tagged,
                    carto_casing_line_width(
                       COALESCE(railway, aeroway),
                       CASE
                         WHEN (bridge IN ('yes', 'boardwalk', 'cantilever', 'covered', 'low_water_crossing', 'movable', 'trestle', 'viaduct')) THEN 'yes'::text
                         WHEN (tags @> 'ford=>yes' OR tags @> 'ford=>stepping_stones') THEN 'ford'::text
                         ELSE 'no'::text
                       END,
                       z(!scale_denominator!)) AS casing_width,
                    COALESCE(layer,0) AS layernotnull,
                    osm_id,
                    z_order
                  FROM planet_osm_line
                  WHERE (railway IS NOT NULL OR aeroway IS NOT NULL)
                    AND way && !bbox! -- end of rail/aero select
              ) AS roads_features
            ), -- end of roads_all CTE
            road_areas_all AS
            (SELECT
                way,
                COALESCE(
                  ('highway_' || (CASE WHEN highway IN ('residential', 'unclassified', 'pedestrian', 'service', 'footway', 'cycleway', 'living_street', 
                                                    'track', 'path', 'platform', 'services') THEN highway ELSE NULL END)),
                  ('railway_' || (CASE WHEN railway IN ('platform') THEN railway ELSE NULL END)),
                  ('aeroway_' || (CASE WHEN aeroway IN ('runway', 'taxiway', 'helipad') THEN aeroway ELSE NULL END))
                ) AS feature,
                carto_path_type(foot, bicycle, horse) AS path_type,
                CASE
                  WHEN surface IN ('unpaved', 'compacted', 'dirt', 'earth', 'fine_gravel', 'grass', 'grass_paver', 'gravel', 'ground',
                                   'mud', 'pebblestone', 'salt', 'sand', 'woodchips', 'clay') THEN 'unpaved'::text
                  WHEN surface IN ('paved', 'asphalt', 'cobblestone', 'cobblestone:flattened', 'sett', 'concrete', 'concrete:lanes',
                                   'concrete:plates', 'paving_stones', 'metal', 'wood') THEN 'paved'::text
                  ELSE NULL
                END AS int_surface,
                CASE
                  WHEN (tunnel IN ('yes', 'building_passage', 'avalanche_protector') OR covered = 'yes') THEN 'yes'::text
                  WHEN (covered = 'yes') THEN 'yes'::text
                  ELSE 'no'::text
                END AS int_tunnel,
                CASE
                  WHEN (bridge IN ('yes', 'boardwalk', 'cantilever', 'covered', 'low_water_crossing', 'movable', 'trestle', 'viaduct')) THEN 'yes'::text
                  WHEN (tags @> 'ford=>yes' OR tags @> 'ford=>stepping_stones') THEN 'ford'::text
                  ELSE 'no'::text
                END AS int_bridge,
                'null' AS int_lane_right,
                'null' AS int_lane_left,
                NULL AS int_lanes,
                carto_road_access(highway, access, tags->'vehicle', tags->'motor_vehicle', tags->'motorcar', bicycle, horse, foot, tags->'bus', tags->'psv') AS int_access,
                construction,
                CASE
                  WHEN service IN ('parking_aisle', 'drive-through', 'driveway') OR leisure IN ('slipway') THEN 'INT-minor'::text
                  ELSE 'INT-normal'::text
                END AS service,
                'no' AS link,
                0 AS width_nominal,
                0 AS width_max,
                0 AS width,
                carto_casing_line_width(
                  highway,
                  CASE
                    WHEN (bridge IN ('yes', 'boardwalk', 'cantilever', 'covered', 'low_water_crossing', 'movable', 'trestle', 'viaduct')) THEN 'yes'::text
                    WHEN (tags @> 'ford=>yes' OR tags @> 'ford=>stepping_stones') THEN 'ford'::text
                    ELSE 'no'::text
                  END,
                  z(!scale_denominator!)) AS casing_width,
                COALESCE(layer,0) AS layernotnull,
                osm_id,
                z_order
              FROM planet_osm_polygon
              WHERE (highway IN ('residential', 'unclassified', 'pedestrian', 'service', 'footway', 'track', 'path', 'platform')
                OR railway IN ('platform')
                OR aeroway IN ('runway', 'taxiway', 'helipad'))
                AND way && !bbox!
                AND z(!scale_denominator!) >= 14
            ), -- end of road_areas_all CTE
            tc_all AS
            (SELECT
                way,
                (CASE WHEN substr(feature, length(feature)-4, 5) = '_link' THEN substr(feature, 0, length(feature)-4) ELSE feature END) AS feature,
                path_type,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                tc_type,
                width,
                carto_casing_line_width(highway, int_bridge, z(!scale_denominator!)) AS casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM
                (WITH tc_combos AS
                  (SELECT DISTINCT ON (p.way)
                      p.way AS way,
                      p.highway AS tc_type,
                      l.way AS lway,
                      ('highway_' || l.highway) AS feature,
                      l.highway AS highway,
                      carto_path_type(l.foot, l.bicycle, l.horse) AS path_type,
                      CASE
                        WHEN surface IN ('unpaved', 'compacted', 'dirt', 'earth', 'fine_gravel', 'grass', 'grass_paver', 'gravel', 'ground',
                                         'mud', 'pebblestone', 'salt', 'sand', 'woodchips', 'clay') THEN 'unpaved'::text
                        WHEN surface IN ('paved', 'asphalt', 'cobblestone', 'cobblestone:flattened', 'sett', 'concrete', 'concrete:lanes',
                                         'concrete:plates', 'paving_stones', 'metal', 'wood') THEN 'paved'::text
                        ELSE NULL
                      END AS int_surface,
                      CASE
                        WHEN (l.tunnel IN ('yes', 'building_passage', 'avalanche_protector') OR covered = 'yes') THEN 'yes'::text
                        WHEN (l.covered = 'yes') THEN 'yes'::text
                        ELSE 'no'::text
                      END AS int_tunnel,
                      CASE
                        WHEN (l.bridge IN ('yes', 'boardwalk', 'cantilever', 'covered', 'low_water_crossing', 'movable', 'trestle', 'viaduct')) THEN 'yes'::text
                        WHEN (l.tags @> 'ford=>yes' OR l.tags @> 'ford=>stepping_stones') THEN 'ford'::text
                        ELSE 'no'::text
                      END AS int_bridge,
                      'null' AS int_lane_right,
                      'null' AS int_lane_left,
                      NULL AS int_lanes,
                      carto_road_access(l.highway, l.access, l.tags->'vehicle', l.tags->'motor_vehicle', l.tags->'motorcar', l.bicycle, l.horse, l.foot, l.tags->'bus', l.tags->'psv') AS int_access,
                      l.construction AS construction,
                      CASE WHEN l.service IN ('parking_aisle', 'drive-through', 'driveway')
                        THEN 'INT-minor'::text
                        ELSE 'INT-normal'::text
                      END AS service,
                      CASE
                        WHEN substr(l.highway, length(l.highway)-4, 5) = '_link' THEN 'yes'
                        ELSE 'no'
                      END AS link,
                      GREATEST(
                        GREATEST(
                          CASE
                            WHEN l.highway = 'track' THEN
                              CASE z(!scale_denominator!)
                                WHEN 15 THEN 5.75
                                WHEN 16 THEN 6.75
                                WHEN 17 THEN 7.75
                                ELSE 8.75
                              END
                            ELSE carto_highway_line_width(l.highway, l.service, z(!scale_denominator!))*1.7
                          END,
                          carto_highway_line_width_mapped(l.highway, l.tags->'width', l.tags->'lanes', !bbox!, !scale_denominator!)*1.375
                        ),
                        CASE WHEN p.tags->'diameter' ~ '^-?\d{1,4}(\.\d+)?$' THEN (p.tags->'diameter')::NUMERIC / NULLIF(scale_factor(p.way)*!scale_denominator!*0.001*0.28,0) ELSE 0.0 END
                      ) AS width,
                      COALESCE(l.layer,0) AS layernotnull,
                      l.osm_id AS osm_id,
                      l.z_order AS z_order
                    FROM planet_osm_point p
                      JOIN planet_osm_line l ON ST_DWithin(p.way, l.way, 0.1) -- Assumes Mercator
                    WHERE p.highway IN ('turning_circle', 'turning_loop', 'mini_roundabout', 'passing_place')
                      AND l.highway IN ('trunk', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link',
                                        'tertiary', 'tertiary_link', 'residential', 'unclassified', 'service',
                                        'living_street', 'track', 'busway', 'bus_guideway')
                      AND p.way && !bbox!
                      AND z(!scale_denominator!) >= 15
                  )
                SELECT
                    ST_MakeLine(way, ST_Translate(way, 0, 0.01)) AS way,
                    feature,
                    highway,
                    path_type,
                    int_surface,
                    int_tunnel,
                    int_bridge,
                    int_lane_right,
                    int_lane_left,
                    int_lanes,
                    int_access,
                    construction,
                    service,
                    link,
                    tc_type,
                    width,
                    layernotnull,
                    osm_id,
                    z_order
                  FROM tc_combos
                  WHERE tc_type IN ('turning_circle', 'turning_loop', 'mini_roundabout')
                UNION ALL
                SELECT
                    ST_LineSubstring(way, GREATEST(0, position-length*0.25*width), LEAST(1, position+length*0.25*width)) AS way,
                    feature,
                    highway,
                    path_type,
                    int_surface,
                    int_tunnel,
                    int_bridge,
                    int_lane_right,
                    int_lane_left,
                    int_lanes,
                    int_access,
                    construction,
                    service,
                    link,
                    tc_type,
                    width,
                    layernotnull,
                    osm_id,
                    z_order
                  FROM
                    (SELECT
                        lway AS way, -- this is the highway intersecting the passing_place node
                        ST_LineLocatePoint(lway, way) AS position, -- this is the position along the way
                        NULLIF(!scale_denominator!*0.001*0.28,0)/ST_Length(lway) AS length, -- this is the pixel size as a fraction of the way length
                        feature,
                        highway,
                        path_type,
                        int_surface,
                        int_tunnel,
                        int_bridge,
                        int_lane_right,
                        int_lane_left,
                        int_lanes,
                        int_access,
                        construction,
                        service,
                        link,
                        tc_type,
                        width,
                        layernotnull,
                        osm_id,
                        z_order
                      FROM tc_combos
                      WHERE tc_type IN ('passing_place')) AS pp_combos
                ) AS turning_circle_features
            ) -- end of tc_all CTE
            SELECT -- casing
                way,
                'casing' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction = 'no'
            UNION ALL
            SELECT -- background
                way,
                'background' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction = 'no'
            UNION ALL
            SELECT -- background_unpaved
                ST_Buffer(way, 0.5*(width_max - 2.0*casing_width)*NULLIF(!scale_denominator!*0.001*0.28,0)) AS way,
                'background_unpaved' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction = 'no'
                AND int_tunnel = 'no'
                AND int_surface = 'unpaved'
                AND width >= 0.0
                AND
                  -- this is all the roads with a fill that is patterened for unpaved roads - only at high zoom and rendered as background
                  feature IN ('highway_bridleway', 'highway_footway', 'highway_cycleway', 'highway_path', 'highway_track')
                AND z(!scale_denominator!) >= 18
            UNION ALL
            SELECT -- fill
                way,
                'fill' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction = 'no'
            UNION ALL
            SELECT -- fill_unpaved
                CASE
                  WHEN feature IN ('aeroway_runway', 'aeroway_taxiway') THEN
                    ST_Buffer(way, 0.5*width_max*NULLIF(!scale_denominator!*0.001*0.28,0), 'endcap=flat join=round')
                  WHEN feature IN ('highway_raceway', 'highway_platform', 'railway_platform') THEN
                    ST_Buffer(way, 0.5*width_max*NULLIF(!scale_denominator!*0.001*0.28,0))
                  ELSE
                    ST_Buffer(way, 0.5*(width_max - 2.0*casing_width)*NULLIF(!scale_denominator!*0.001*0.28,0))
                END AS way,
                'fill_unpaved' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction = 'no'
                AND int_tunnel = 'no'
                AND int_surface = 'unpaved'
                AND
                  -- this is all the roads with a fill that is patterened for unpaved roads
                  feature IN (
                    'highway_motorway', 'highway_trunk', 'highway_primary', 'highway_secondary', 'highway_tertiary', 'highway_unclassified',
                    'highway_residential', 'highway_service', 'highway_road', 'highway_pedestrian', 'highway_living_street', 'highway_raceway',
                    'highway_busway', 'highway_bus_guideway',
                    'highway_platform', 'railway_platform', 'aeroway_runway', 'aeroway_taxiway')
                AND z(!scale_denominator!) >= 12
            UNION ALL
            SELECT -- junction_casing
                way,
                'junction_casing' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction != 'no'
            UNION ALL
            SELECT -- junction_fill
                way,
                'junction_fill' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction != 'no'
            UNION ALL
            SELECT -- centerline
                way,
                'centerline' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction = 'no'
                AND int_tunnel = 'no'
                AND feature IN ('highway_living_street', 'highway_pedestrian', 'highway_busway', 'highway_bus_guideway', 'aeroway_runway', 'aeroway_taxiway')
                AND z(!scale_denominator!) >= 15
            UNION ALL
            SELECT -- lanes
                way,
                'lanes' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction = 'no'
                AND int_tunnel = 'no'
                AND int_lanes IS NOT NULL
                AND z(!scale_denominator!) >= 18
            UNION ALL
            SELECT -- access
                way,
                'access' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction = 'no'
                AND int_tunnel = 'no'
                AND int_access IS NOT NULL
                AND z(!scale_denominator!) >= 15
            UNION ALL
            SELECT -- centerline_top
                way,
                'centerline_top' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM roads_all
              WHERE int_junction = 'no'
                AND int_tunnel = 'no'
                AND int_bridge IN ('ford', 'ford_node',  'mountain_pass')
                AND z(!scale_denominator!) >= 15
            UNION ALL
            SELECT -- area_casing
                way,
                'area_casing' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM road_areas_all
              WHERE feature NOT IN ('aeroway_runway', 'aeroway_taxiway', 'aeroway_helipad')
            UNION ALL
            SELECT -- area_fill
                way,
                'area_fill' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                'null' AS tc_type,
                width_nominal,
                width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM road_areas_all
            UNION ALL
            SELECT -- tc_casing
                way,
                'tc_casing' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                tc_type,
                0 AS width_nominal,
                0 AS width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM tc_all
            UNION ALL
            SELECT -- tc_fill
                way,
                'tc_fill' AS road_layer,
                feature,
                path_type,
                'no' AS intermittent,
                'no' AS seasonal,
                int_surface,
                int_tunnel,
                int_bridge,
                int_lane_right,
                int_lane_left,
                int_lanes,
                int_access,
                construction,
                service,
                link,
                tc_type,
                0 AS width_nominal,
                0 AS width_max,
                width,
                casing_width,
                layernotnull,
                osm_id,
                z_order
              FROM tc_all
            UNION ALL
            SELECT -- waterway_bridges_casing
                way,
                'waterway_bridges_casing' AS road_layer,
                ('waterway_' || waterway) AS feature,
                'null' AS path_type,
                tags->'intermittent' AS intermittent,
                tags->'seasonal' AS seasonal,
                'null' AS int_surface,
                CASE WHEN tunnel IN ('yes', 'culvert') THEN 'yes' ELSE 'no' END AS int_tunnel,
                'yes' AS int_bridge,
                'null' AS int_lane_right,
                'null' AS int_lane_left,
                'null' AS int_lanes,
                'null' AS int_access,
                'null' AS construction,
                'null' AS service,
                'no' AS link,
                'null' tc_type,
                0 AS width_nominal,
                0 AS width_max,
                0 AS width,
                0 AS casing_width,
                COALESCE(layer,0) AS layernotnull,
                osm_id,
                z_order
              FROM planet_osm_line
              WHERE waterway IN ('river', 'canal', 'stream', 'drain', 'ditch', 'wadi')
                AND bridge IN ('yes', 'aqueduct')
                AND way && !bbox!
                AND z(!scale_denominator!) >= 12
            UNION ALL
            SELECT -- waterway_bridges_fill
                way,
                'waterway_bridges_fill' AS road_layer,
                ('waterway_' || waterway) AS feature,
                'null' AS path_type,
                tags->'intermittent' AS intermittent,
                tags->'seasonal' AS seasonal,
                'null' AS int_surface,
                CASE WHEN tunnel IN ('yes', 'culvert') THEN 'yes' ELSE 'no' END AS int_tunnel,
                'yes' AS int_bridge,
                'null' AS int_lane_right,
                'null' AS int_lane_left,
                'null' AS int_lanes,
                'null' AS int_access,
                'null' AS construction,
                'null' AS service,
                'no' AS link,
                'null' tc_type,
                0 AS width_nominal,
                0 AS width_max,
                0 AS width,
                0 AS casing_width,
                COALESCE(layer,0) AS layernotnull,
                osm_id,
                z_order
              FROM planet_osm_line
              WHERE waterway IN ('river', 'canal', 'stream', 'drain', 'ditch', 'wadi')
                AND bridge IN ('yes', 'aqueduct')
                AND way && !bbox!
                AND z(!scale_denominator!) >= 12
            UNION ALL
            SELECT -- line_barriers
                way,
                'line_barriers' AS road_layer,
                COALESCE(historic, barrier) AS feature,
                'null' AS path_type,
                'null' AS intermittent,
                'null' AS seasonal,
                'null' AS int_surface,
                'no' AS int_tunnel,
                'no' AS int_bridge,
                'null' AS int_lane_right,
                'null' AS int_lane_left,
                'null' AS int_lanes,
                'null' AS int_access,
                'null' AS construction,
                'null' AS service,
                'no' AS link,
                'null' tc_type,
                0 AS width_nominal,
                0 AS width_max,
                0 AS width,
                0 AS casing_width,
                COALESCE(layer,0) AS layernotnull,
                osm_id,
                z_order
              FROM (
                -- line barriers without intersecting barrier=entrance nodes
                SELECT way,
                    ('barrier_' || (CASE WHEN barrier IN ('chain', 'city_wall', 'ditch', 'fence', 'guard_rail',
                     'handrail', 'retaining_wall', 'wall') THEN barrier ELSE NULL END)) AS barrier,
                    ('historic_' || (CASE WHEN historic = 'citywalls' THEN historic ELSE NULL END)) AS historic,
                    layer,
                    osm_id,
                    z_order
                  FROM planet_osm_line l
                  WHERE (barrier IN ('chain', 'city_wall', 'ditch', 'fence', 'guard_rail',
                        'handrail', 'retaining_wall', 'wall')
                    OR historic = 'citywalls')
                    AND (waterway IS NULL OR waterway NOT IN ('river', 'canal', 'derelict_canal', 'stream', 'drain', 'ditch', 'wadi'))
                    AND (l.way && !bbox!)
                    AND NOT EXISTS
                      (SELECT 1 FROM planet_osm_point e WHERE ST_Intersects(l.way, e.way)
                        AND e.barrier IN ('entrance'))
                UNION ALL
                -- barriers with entrance nodes cut out
                SELECT
                    ST_Difference(
                      l.way,
                      ST_Union(ST_Buffer(
                        e.way,
                        (COALESCE(
                          (SELECT
                             GREATEST(
                              carto_highway_line_width(highway, service, z(!scale_denominator!)),
                              carto_highway_line_width_mapped(highway, tags->'width', tags->'lanes', !bbox!, !scale_denominator!))
                             FROM planet_osm_line h
                             WHERE ST_Intersects(h.way, e.way) AND highway IN 
                              ('motorway', 'motorway_link', 'trunk', 'trunk_link', 'primary', 'primary_link', 'secondary', 
                               'secondary_link', 'tertiary', 'tertiary_link', 'residential', 'unclassified', 'service', 
                               'living_street', 'pedestrian', 'steps', 'road', 'bridleway', 'footway', 'cycleway', 'path', 'track',
                               'busway', 'bus_guideway')
                              ORDER BY carto_highway_line_width(highway, service, z(!scale_denominator!)) DESC LIMIT 1
                          ),
                          carto_highway_line_width('footway', z(!scale_denominator!))
                        ) + 2.5 + carto_barrier_line_width(
                              CASE WHEN l.historic = 'citywalls' THEN l.historic ELSE l.barrier END,
                              z(!scale_denominator!)
                        ))*0.5*NULLIF(!scale_denominator!*0.001*0.28,0)
                      ))
                    ) AS way,
                    ('barrier_' || (CASE WHEN l.barrier IN ('chain', 'city_wall', 'ditch', 'fence', 'guard_rail',
                     'handrail', 'retaining_wall', 'wall') THEN l.barrier ELSE NULL END)) AS barrier,
                    ('historic_' || (CASE WHEN l.historic = 'citywalls' THEN l.historic ELSE NULL END)) AS historic,
                    l.layer AS layer,
                    l.osm_id AS osm_id,
                    l.z_order AS z_order
                  FROM planet_osm_point e
                  JOIN planet_osm_line l ON ST_Intersects(l.way, e.way)
                  WHERE e.barrier IN ('entrance')
                    AND (e.way && ST_Expand(!bbox!, (0.5*(carto_highway_line_width('motorway', z(!scale_denominator!)) + 2.0 +
                         carto_barrier_line_width(
                           CASE WHEN l.historic = 'citywalls' THEN l.historic ELSE l.barrier END,
                           z(!scale_denominator!)
                         ))*NULLIF(!scale_denominator!*0.001*0.28,0))))
                    AND (l.barrier IN ('chain', 'city_wall', 'ditch', 'fence', 'guard_rail',
                        'handrail', 'retaining_wall', 'wall')
                      OR l.historic = 'citywalls')
                    AND (l.waterway IS NULL OR l.waterway NOT IN ('river', 'canal', 'derelict_canal', 'stream', 'drain', 'ditch', 'wadi'))
                    AND (l.way && !bbox!)
                    GROUP BY l.way, l.barrier, l.historic, l.layer, l.osm_id, l.z_order
                ) AS line_barriers
                WHERE z(!scale_denominator!) >= 15
            UNION ALL
            SELECT -- ferry_routes
                way,
                'ferry_routes' AS road_layer,
                'ferry' AS feature,
                'null' AS path_type,
                'null' AS intermittent,
                'null' AS seasonal,
                'null' AS int_surface,
                'no' AS int_tunnel,
                'no' AS int_bridge,
                'null' AS int_lane_right,
                'null' AS int_lane_left,
                'null' AS int_lanes,
                'null' AS int_access,
                'null' AS construction,
                'null' AS service,
                'no' AS link,
                'null' tc_type,
                0 AS width_nominal,
                0 AS width_max,
                0 AS width,
                0 AS casing_width,
                0 AS layernotnull,
                osm_id,
                z_order
              FROM planet_osm_line
              WHERE route = 'ferry'
                AND way && !bbox!
            UNION ALL
            SELECT -- landuse_overlay
                way,
                'landuse_overlay' AS road_layer,
                ('landuse_' || landuse) AS feature,
                'null' AS path_type,
                'null' AS intermittent,
                'null' AS seasonal,
                'null' AS int_surface,
                'no' AS int_tunnel,
                'no' AS int_bridge,
                'null' AS int_lane_right,
                'null' AS int_lane_left,
                'null' AS int_lanes,
                'null' AS int_access,
                'null' AS construction,
                'null' AS service,
                'no' AS link,
                'null' tc_type,
                0 AS width_nominal,
                0 AS width_max,
                way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS width,
                0 AS casing_width,
                0 AS layernotnull,
                osm_id,
                z_order
              FROM planet_osm_polygon
              WHERE landuse = 'military'
                AND building IS NULL
                AND way && !bbox!
            ) AS roads_sublayers
          -- this is the full ordering of the roads stack
          ORDER BY
            CASE
              WHEN int_bridge IN ('yes') THEN layernotnull + 100
              WHEN int_tunnel NOT IN ('no') THEN layernotnull - 100
              ELSE 0
            END,
            -- this defines the orering of layers as far as it has priority over the
            -- layer and z_oder of normal non-bridge and non-tunnel features, that is:
            --  * the non-roads layers
            --  * the casing-background-fill progression
            -- ordering beyond that is defined later because
            -- it is subordinate to the layer and z_oder
            CASE
              -- this is bridges only so it comes after all the non-bridge layers and before the road bridge layers
              WHEN road_layer = 'waterway_bridges_casing' THEN 0
              WHEN road_layer = 'waterway_bridges_fill' THEN 1
              WHEN road_layer = 'landuse_overlay' THEN 2
              WHEN road_layer = 'line_barriers' THEN 3
              WHEN road_layer = 'ferry_routes' THEN 4
              WHEN road_layer = 'tc_casing' THEN 5
              WHEN road_layer = 'area_casing' THEN 5
              WHEN road_layer = 'junction_casing' THEN 5
              WHEN road_layer = 'casing' THEN 5
              WHEN road_layer = 'background' THEN 6
              WHEN road_layer = 'background_unpaved' THEN 6
              WHEN road_layer = 'area_fill' THEN 7
              WHEN road_layer = 'junction_fill' THEN 7
              WHEN road_layer = 'fill' THEN 7
              WHEN road_layer = 'fill_unpaved' THEN 7
              WHEN road_layer = 'centerline' THEN 7
              WHEN road_layer = 'lanes' THEN 7
              WHEN road_layer = 'access' THEN 7
              WHEN road_layer = 'tc_fill' THEN 7
              WHEN road_layer = 'centerline_top' THEN 8
            END,
            layernotnull,
            z_order,
            CASE
              WHEN road_layer = 'waterway_bridges_casing' THEN 0
              WHEN road_layer = 'waterway_bridges_fill' THEN 1
              WHEN road_layer = 'landuse_overlay' THEN 2
              WHEN road_layer = 'line_barriers' THEN 3
              WHEN road_layer = 'ferry_routes' THEN 4
              WHEN road_layer = 'tc_casing' THEN 5
              WHEN road_layer = 'area_casing' THEN 6
              WHEN road_layer = 'junction_casing' THEN 7
              WHEN road_layer = 'casing' THEN 8
              WHEN road_layer = 'background' THEN 9
              WHEN road_layer = 'background_unpaved' THEN 9
              WHEN road_layer = 'area_fill' THEN 10
              WHEN road_layer = 'junction_fill' THEN 11
              WHEN road_layer = 'fill' THEN 12
              WHEN road_layer = 'fill_unpaved' THEN 12
              WHEN road_layer = 'centerline' THEN 13
              WHEN road_layer = 'lanes' THEN 14
              WHEN road_layer = 'access' THEN 15
              WHEN road_layer = 'tc_fill' THEN 16
              WHEN road_layer = 'centerline_top' THEN 17
            END,
            CASE WHEN substr(feature, 1, 16) = 'highway_sidewalk' THEN 0 ELSE 1 END,
            -- order by how permissive it is to the target map user
            CASE
              WHEN int_access IN ('no') THEN 0
              WHEN int_access IN ('bus') THEN 1
              WHEN int_access IN ('foot') THEN 2
              WHEN int_access IN ('horse') THEN 3
              WHEN int_access IN ('bicycle') THEN 4
              WHEN int_access IN ('vehicle') THEN 5
              WHEN int_access IN ('light') THEN 6
              WHEN int_access IN ('bus+light') THEN 7
              WHEN int_access IN ('foot+light') THEN 8
              WHEN int_access IN ('horse+light') THEN 9
              WHEN int_access IN ('bicycle+light') THEN 10
              WHEN int_access IN ('vehicle+light') THEN 11
              ELSE 10
            END,
            CASE WHEN int_surface IN ('unpaved') THEN 0 ELSE 1 END,
            CASE WHEN int_bridge IN ('mountain_pass', 'ford_node') THEN 1 ELSE 0 END,
            osm_id
        ) AS roads_sql
    properties:
      minzoom: 10
  - id: golf-lines
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way, geo, golf, ref, name_label[1] AS name, name_label[3] AS font
          FROM
            (SELECT
                way, tags->'golf' AS golf, carto_label_name(way, name, tags, E'\n') AS name_label, ref, 0 AS prio, 'polygon' AS geo
              FROM planet_osm_polygon
              WHERE (tags->'golf') IS NOT NULL AND way && !bbox!
            UNION ALL
            SELECT
                p.way, p.tags->'golf' AS golf, carto_label_name(p.way, p.name, p.tags, E'\n') AS name_label, coalesce(p.ref,l.ref) AS ref, 0 AS prio, 'point' AS geo
              FROM planet_osm_point p LEFT JOIN planet_osm_line l ON (ST_Intersects(p.way, l.way) AND (l.tags->'golf') IS NOT NULL)
              WHERE p.tags ? 'golf' AND p.way && !bbox!
            UNION ALL
            SELECT
                way, tags->'golf' AS golf, carto_label_name(way, name, tags, E'\n') AS name_label, ref, 1 AS prio, 'line' AS geo
              FROM planet_osm_line WHERE (tags->'golf') IS NOT NULL AND way && !bbox!
            ) AS golf
          ORDER BY prio
        ) AS golf_lines
    properties:
      minzoom: 16
  - id: aerialways
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            aerialway
          FROM planet_osm_line
          WHERE aerialway IS NOT NULL
        ) AS aerialways
    properties:
      minzoom: 12
  - id: necountries
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM ne_110m_admin_0_boundary_lines_land
        ) AS necountries
    properties:
      minzoom: 1
      maxzoom: 3
  - id: admin-low-zoom
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            admin_level,
            tags->'maritime' as maritime
          FROM planet_osm_roads
          WHERE boundary = 'administrative'
            AND admin_level IN ('0', '1', '2', '3', '4')
            AND (osm_id < 0 OR (osm_id > 0 AND tags @> 'maritime=>yes'))
          ORDER BY admin_level DESC,
            CASE
              WHEN tags @> 'maritime=>yes' THEN 1
              ELSE 0
            END ASC
        ) AS admin_low_zoom
    properties:
      minzoom: 4
      maxzoom: 10
  - id: admin-mid-zoom
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            admin_level,
            tags->'maritime' as maritime
          FROM planet_osm_roads
          WHERE boundary = 'administrative'
            AND admin_level IN ('0', '1', '2', '3', '4', '5', '6', '7', '8')
            AND (osm_id < 0 OR (osm_id > 0 AND tags @> 'maritime=>yes'))
          ORDER BY admin_level DESC,
            CASE
              WHEN tags @> 'maritime=>yes' THEN 1
              ELSE 0
            END ASC
        ) AS admin_mid_zoom
    properties:
      minzoom: 11
      maxzoom: 12
  - id: admin-high-zoom
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            admin_level,
            tags->'maritime' as maritime
          FROM planet_osm_roads
          WHERE boundary = 'administrative'
            AND admin_level IN ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10')
            AND (osm_id < 0 OR (osm_id > 0 AND tags @> 'maritime=>yes'))
          ORDER BY admin_level::integer DESC, -- With 10 as a valid value, we need to do a numeric ordering, not a text ordering
            CASE
              WHEN tags @> 'maritime=>yes' THEN 1
              ELSE 0
            END ASC
        ) AS admin_high_zoom
    properties:
      minzoom: 13
  - id: power-minorline
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM planet_osm_line
          WHERE power = 'minor_line'
        ) AS power_minorline
    properties:
      minzoom: 16
  - id: power-line
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM planet_osm_line
          WHERE power = 'line'
        ) AS power_line
    properties:
      minzoom: 14
  - id: tourism-boundary
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            way_pixels,
            name_label[1] AS name,
            name_label[3] AS font,
            tourism
          FROM
            (SELECT
                way,
                way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels,
                carto_label_name(way, name, tags, E'\n') AS name_label,
                tourism
              FROM planet_osm_polygon
              WHERE tourism = 'theme_park'
                OR tourism = 'zoo') AS _
        ) AS tourism_boundary
    properties:
      minzoom: 10
  - id: trees
    geometry: polygon
    <<: *extents
    Datasource:
      geometry_table: planet_osm_point
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            type
          FROM
            (WITH tree_points AS
              (SELECT
                  CASE WHEN ((width_px % 2) = 0) THEN
                    ST_SnapToGrid(
                      way,
                      NULLIF(!scale_denominator!*0.001*0.28,0), NULLIF(!scale_denominator!*0.001*0.28,0))
                  ELSE
                    ST_SnapToGrid(
                      way,
                      0.5*NULLIF(!scale_denominator!*0.001*0.28,0), 0.5*NULLIF(!scale_denominator!*0.001*0.28,0),
                      NULLIF(!scale_denominator!*0.001*0.28,0), NULLIF(!scale_denominator!*0.001*0.28,0))
                  END AS point,
                  (SELECT
                      COALESCE(
                        ST_Union(
                          CASE WHEN t2.leaf_type IN ('palm') THEN
                            ST_Buffer(
                              ST_Translate(
                                carto_symbol_from_db(
                                  'tree',
                                  t2.width_px*NULLIF(!scale_denominator!*0.001*0.28,0),
                                  t2.width_px,
                                  t2.leaf_type,
                                  t2.leaf_cycle
                                ),
                                ST_X(t2.way),
                                ST_Y(t2.way)
                              ),
                              (CASE WHEN width_px > 30 THEN 1.6 WHEN width_px < 15 THEN 1.0 ELSE 1.0 + 0.6*(width_px-15)/15.0 END)*NULLIF(!scale_denominator!*0.001*0.28,0)
                            )
                          ELSE
                            St_Buffer(t2.way, (t2.width_px+2.0)*NULLIF(!scale_denominator!*0.001*0.28,0)*0.5)
                          END
                        ),
                        ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                      )
                    FROM
                      (SELECT
                          CASE WHEN ((width_px % 2) = 0) THEN
                            ST_SnapToGrid(
                              way,
                              NULLIF(!scale_denominator!*0.001*0.28,0), NULLIF(!scale_denominator!*0.001*0.28,0))
                          ELSE
                            ST_SnapToGrid(
                              way,
                              0.5*NULLIF(!scale_denominator!*0.001*0.28,0), 0.5*NULLIF(!scale_denominator!*0.001*0.28,0),
                              NULLIF(!scale_denominator!*0.001*0.28,0), NULLIF(!scale_denominator!*0.001*0.28,0))
                          END AS way,
                          height,
                          hash,
                          width_px,
                          leaf_type,
                          leaf_cycle
                        FROM
                          (SELECT
                              way,
                              CASE
                                WHEN tags->'height' ~ '^-?\d{1,3}(\.\d+)?$' THEN (tags->'height')::NUMERIC
                                ELSE 0.0
                              END AS height,
                              osm_id AS hash,
                              GREATEST(
                                carto_barrier_line_width("natural", z(!scale_denominator!)),
                                -- we round the mapped width to integer pixels to possibly get a pixel aligned symbol
                                -- and cap it at 60 pixel to avoid blowing up existing symbols too much
                                LEAST(carto_tree_diameter_mapped(
                                  "natural",
                                  (CASE WHEN "natural" = 'shrub' THEN tags->'width' ELSE tags->'diameter_crown' END),
                                  tags->'height',
                                  tags->'circumference',
                                  tags->'diameter',
                                  !bbox!,
                                  !scale_denominator!), 60)
                              ) AS width_px,
                              carto_leaf_type_classify(tags->'leaf_type', tags->'species', tags->'genus', tags->'family', tags->'taxon', NULL) AS leaf_type,
                              tags->'leaf_cycle' AS leaf_cycle
                            FROM planet_osm_point
                            WHERE "natural" IN ('tree', 'shrub')
                              -- this search radius expansion is based on the upper bound for practical width_px 
                              -- considering there are very few trees with more than 50m crown diameter in reality
                              AND way && ST_Expand(
                                t1.way,
                                0.5*(t1.width_px+GREATEST(t1.width_px,
                                  LEAST(carto_tree_diameter_mapped('tree', '50', NULL, NULL, NULL, !bbox!, !scale_denominator!), 60))+2.0)*
                                  NULLIF(!scale_denominator!*0.001*0.28,0))
                          ) AS _
                      ) AS t2
                    WHERE ((t2.height > t1.height) OR ((t2.height = t1.height) AND (t2.width_px > t1.width_px)) OR ((t2.height = t1.height) AND (t2.width_px = t1.width_px) AND (t2.hash > t1.hash)))
                      AND ST_DWithin(t2.way, t1.way, 0.5*(t1.width_px+t2.width_px+2.0)*NULLIF(!scale_denominator!*0.001*0.28,0))
                      AND t2.width_px >= 5
                      AND t1.width_px >= 5
                  ) AS others,
                  carto_leaf_type_classify(leaf_type, species, genus, family, taxon, NULL) AS leaf_type,
                  leaf_cycle,
                  width_px,
                  width_px*NULLIF(!scale_denominator!*0.001*0.28,0) AS width
                FROM
                  (SELECT
                      way,
                      CASE
                        WHEN tags->'height' ~ '^-?\d{1,3}(\.\d+)?$' THEN (tags->'height')::NUMERIC
                        ELSE 0.0
                      END AS height,
                      osm_id AS hash,
                      tags->'leaf_type' AS leaf_type,
                      tags->'leaf_cycle' AS leaf_cycle,
                      tags->'taxon' AS taxon,
                      tags->'family' AS family,
                      tags->'genus' AS genus,
                      tags->'species' AS species,
                      GREATEST(
                        carto_barrier_line_width("natural", z(!scale_denominator!)),
                        -- we round the mapped width to integer pixels to possibly get a pixel aligned symbol
                        -- and cap it at 60 pixel to avoid blowing up existing symbols too much
                        LEAST(carto_tree_diameter_mapped(
                          "natural",
                          (CASE WHEN "natural" = 'shrub' THEN tags->'width' ELSE tags->'diameter_crown' END),
                          tags->'height',
                          tags->'circumference',
                          tags->'diameter',
                          !bbox!,
                          !scale_denominator!), 60)
                      ) AS width_px
                    FROM planet_osm_point
                    WHERE "natural" IN ('tree', 'shrub') AND way && !bbox!) AS t1
              ),
            tree_rows AS
              (SELECT
                  way,
                  feature,
                  length,
                  height,
                  leaf_type,
                  leaf_cycle,
                  taxon,
                  family,
                  genus,
                  species,
                  width_px,
                  width_px*NULLIF(!scale_denominator!*0.001*0.28,0) AS width
                FROM
                  (SELECT
                      way,
                      COALESCE("natural", barrier) AS feature,
                      ST_Length(way)*(CASE WHEN "natural" = 'tree_row' THEN 1000 ELSE 1.0 END) AS length,
                      CASE
                        WHEN tags->'height' ~ '^-?\d{1,3}(\.\d+)?$' THEN (tags->'height')::NUMERIC
                        ELSE 0.0
                      END AS height,
                      tags->'leaf_type' AS leaf_type,
                      tags->'leaf_cycle' AS leaf_cycle,
                      tags->'taxon' AS taxon,
                      tags->'family' AS family,
                      tags->'genus' AS genus,
                      tags->'species' AS species,
                      GREATEST(
                        carto_barrier_line_width(COALESCE("natural", barrier), z(!scale_denominator!)),
                        -- we do not round the mapped width here because tree row symbols are not pixel aligned
                        -- we cap it at 60 pixel to avoid blowing up existing symbols too much
                        LEAST(carto_treerow_line_width_mapped(COALESCE("natural", barrier), tags->'width', tags->'height', !bbox!, !scale_denominator!), 60)
                      ) AS width_px
                    FROM planet_osm_line
                    WHERE ("natural" = 'tree_row' OR barrier = 'hedge') AND way && !bbox!
                  ) AS _
              ),
            row_trees_raw AS
              (SELECT
                  way,
                  others
                FROM
                  (SELECT
                      point,
                      ST_Translate(
                        carto_symbol_from_db(
                          'tree',
                          width,
                          width_px,
                          leaf_type,
                          leaf_cycle
                        ),
                        ST_X(point),
                        ST_Y(point)
                      ) AS way,
                      COALESCE(
                        ST_Union(
                          St_Difference(
                            St_Buffer(prev_next, width*0.5),
                            COALESCE(
                              St_ConvexHull(
                                St_Collect(
                                  St_Intersection(
                                    ST_Boundary(
                                      St_Buffer(prev_next, width*0.5)
                                    ),
                                    ST_Boundary(
                                      St_Buffer(point, width*0.5)
                                    )
                                  ),
                                  St_Buffer(point, width*0.25)
                                )
                              ),
                              ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                            )
                          ),
                          (SELECT
                              COALESCE(
                                ST_Union(way),
                                ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                              )
                            FROM
                              -- these are other single trees
                              (SELECT
                                  St_Buffer(way, (width_px+2.0)*NULLIF(!scale_denominator!*0.001*0.28,0)*0.5) AS way
                                FROM
                                  (SELECT
                                      CASE WHEN ((width_px % 2) = 0) THEN
                                        ST_SnapToGrid(
                                          way,
                                          NULLIF(!scale_denominator!*0.001*0.28,0), NULLIF(!scale_denominator!*0.001*0.28,0))
                                      ELSE
                                        ST_SnapToGrid(
                                          way,
                                          0.5*NULLIF(!scale_denominator!*0.001*0.28,0), 0.5*NULLIF(!scale_denominator!*0.001*0.28,0),
                                          NULLIF(!scale_denominator!*0.001*0.28,0), NULLIF(!scale_denominator!*0.001*0.28,0))
                                      END AS way,
                                      width_px
                                    FROM
                                      (SELECT
                                          way,
                                          GREATEST(
                                            carto_barrier_line_width("natural", z(!scale_denominator!)),
                                            -- we round the mapped width to integer pixels to possibly get a pixel aligned symbol
                                            -- and cap it at 60 pixel to avoid blowing up existing symbols too much
                                            LEAST(carto_tree_diameter_mapped(
                                              "natural",
                                              (CASE WHEN "natural" = 'shrub' THEN tags->'width' ELSE tags->'diameter_crown' END),
                                              tags->'height',
                                              tags->'circumference',
                                              tags->'diameter',
                                              !bbox!,
                                              !scale_denominator!), 60)
                                          ) AS width_px
                                        FROM planet_osm_point
                                        WHERE "natural" IN ('tree', 'shrub')
                                          -- this search radius expansion is based on the upper bound for practical width_px 
                                          -- considering there are very few trees with more than 50m crown diameter in reality
                                          AND way && ST_Expand(
                                            t1.point,
                                            0.5*(t1.width_px+GREATEST(t1.width_px,
                                              LEAST(carto_tree_diameter_mapped('tree', '50', NULL, NULL, NULL, !bbox!, !scale_denominator!), 60))+2.0)*
                                              NULLIF(!scale_denominator!*0.001*0.28,0))
                                      ) AS _
                                  ) AS t2
                                WHERE ST_DWithin(t2.way, t1.point, 0.5*(t1.width_px+t2.width_px+2.0)*NULLIF(!scale_denominator!*0.001*0.28,0))
                                  AND t2.width_px >= 5
                                  AND t1.width_px >= 5
                              UNION ALL
                              -- these are other tree rows/hedges - treated as whole (buffered) lines
                              SELECT
                                  St_Buffer(way, (width_px+2.0)*NULLIF(!scale_denominator!*0.001*0.28,0)*0.5) AS way
                                FROM
                                  (SELECT
                                      way,
                                      ST_Length(way)*(CASE WHEN "natural" = 'tree_row' THEN 1000 ELSE 1.0 END) AS length,
                                      CASE
                                        WHEN tags->'height' ~ '^-?\d{1,3}(\.\d+)?$' THEN (tags->'height')::NUMERIC
                                        ELSE 0.0
                                      END AS height,
                                      tags->'leaf_type' AS leaf_type,
                                      tags->'leaf_cycle' AS leaf_cycle,
                                      tags->'taxon' AS taxon,
                                      tags->'family' AS family,
                                      tags->'genus' AS genus,
                                      tags->'species' AS species,
                                      GREATEST(
                                        carto_barrier_line_width(COALESCE("natural", barrier), z(!scale_denominator!)),
                                        -- we do not round the mapped width here because tree row symbols are not pixel aligned
                                        -- we cap it at 60 pixel to avoid blowing up existing symbols too much
                                        LEAST(carto_treerow_line_width_mapped(COALESCE("natural", barrier), tags->'width', tags->'height', !bbox!, !scale_denominator!), 60)
                                      ) AS width_px
                                    FROM planet_osm_line
                                    WHERE ("natural" = 'tree_row' OR barrier = 'hedge')
                                      -- based on both tree rows always being drawn at the same width
                                      AND way && ST_Expand(
                                        t1.point,
                                        (t1.width_px+1.0)*NULLIF(!scale_denominator!*0.001*0.28,0))
                                  ) AS t2
                                WHERE ((t2.height > t1.height) OR ((t2.height = t1.height) AND (t2.width_px > t1.width_px)) OR ((t2.height = t1.height) AND (t2.width_px = t1.width_px) AND (t2.length > t1.length)))
                                  AND ST_DWithin(t2.way, t1.point, 0.5*(t1.width_px+t2.width_px+2.0)*NULLIF(!scale_denominator!*0.001*0.28,0))
                                  AND t2.width_px >= 5
                                  AND t1.width_px >= 5) AS o
                          )
                        ), ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)
                      ) AS others,
                      point_index,
                      is_closed,
                      length,
                      height,
                      leaf_type,
                      leaf_cycle,
                      width,
                      width_px
                    FROM
                      (SELECT
                          point,
                          point_index,
                          prev_next,
                          line,
                          is_closed,
                          length,
                          height,
                          carto_leaf_type_classify(leaf_type, species, genus, family, taxon, point_index) AS leaf_type,
                          leaf_cycle,
                          width,
                          width_px
                        FROM
                          (SELECT
                              (way_points).geom AS point,
                              (way_points).path[1] AS point_index,
                              (CASE WHEN carto_leaf_type_classify(leaf_type, species, genus, family, taxon, 0) IS NULL THEN
                                ST_Union(
                                  COALESCE(ST_PointN(way_seg, CASE WHEN (way_points).path[1] = 1 THEN -1 ELSE (way_points).path[1]-1 END), ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)),
                                  COALESCE(ST_PointN(way_seg, (way_points).path[1]+1), ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857))
                                )
                              ELSE
                                -- ST_PointN(way_seg, CASE WHEN (way_points).path[1] = 1 THEN -1 ELSE (way_points).path[1]-1 END)
                                ST_Union(
                                  COALESCE(ST_PointN(way_seg, CASE WHEN (way_points).path[1] = 1 THEN -1 ELSE (way_points).path[1]-1 END), ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857)),
                                  COALESCE(ST_PointN(way_seg, (way_points).path[1]+1), ST_SetSRID('GEOMETRYCOLLECTION EMPTY'::geometry, 3857))
                                )
                              END) AS prev_next,
                              line,
                              is_closed,
                              length,
                              height,
                              leaf_type,
                              leaf_cycle,
                              taxon,
                              family,
                              genus,
                              species,
                              width,
                              width_px
                            FROM
                              (SELECT
                                  ST_DumpPoints(way_seg) AS way_points,
                                  start_point,
                                  way_seg,
                                  line,
                                  is_closed,
                                  length,
                                  height,
                                  leaf_type,
                                  leaf_cycle,
                                  taxon,
                                  family,
                                  genus,
                                  species,
                                  width,
                                  width_px
                                FROM
                                  (SELECT
                                      ST_Segmentize(way, 0.75*width) AS way_seg,
                                      ST_StartPoint(way) AS start_point,
                                      way AS line,
                                      ST_IsClosed(way) AS is_closed,
                                      length,
                                      height,
                                      leaf_type,
                                      leaf_cycle,
                                      taxon,
                                      family,
                                      genus,
                                      species,
                                      width,
                                      width_px
                                    FROM tree_rows
                                    WHERE width_px >= 5
                                  ) AS tree_rows_seg_raw
                              ) AS tree_rows_seg
                            -- we skip the first point for closed ways to avoid a duplicate position
                            WHERE CASE WHEN is_closed THEN NOT(ST_Equals((way_points).geom, start_point)) ELSE TRUE END
                          ) AS t1a
                        -- we can speed things up quite a bit at the higher zoom levels by dropping points outside the bounding box
                        -- for tree rows/hedges much larger than the bounding box
                        WHERE point && ST_Expand(!bbox!,(width_px+1.0)*NULLIF(!scale_denominator!*0.001*0.28,0))
                      ) AS t1
                  ) AS _
              ),
            row_trees AS
              (SELECT
                  ST_Difference(
                    way,
                    others
                  ) AS way,
                  'row_tree' AS type
                FROM row_trees_raw
              ),
            single_trees AS
              (SELECT
                  ST_Difference(
                    ST_Translate(
                      carto_symbol_from_db(
                        'tree',
                        width,
                        width_px,
                        leaf_type,
                        leaf_cycle
                      ),
                      ST_X(point),
                      ST_Y(point)
                    ),
                    others
                  ) AS way,
                  'tree' AS type
                FROM tree_points
                WHERE width_px >= 5
              ),
            trees_small AS
              (SELECT
                  St_Buffer(point, width*0.5) AS way,
                  'tree_small' AS type
                FROM tree_points
                WHERE width_px < 5
              UNION ALL
              SELECT
                  St_Buffer(way, width*0.5) AS way,
                  feature AS type
                FROM tree_rows
                WHERE width_px < 5)
            SELECT
                way,
                type
              FROM single_trees
            UNION ALL
            SELECT
                way,
                type
              FROM row_trees
            UNION ALL
            SELECT
                way,
                type
              FROM trees_small
            ) AS _
        ) AS trees
    properties:
      minzoom: 16
  - id: country-names
    class: country
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            way_pixels,
            name_label[1] AS name,
            name_label[3] AS font
          FROM
            (SELECT
                way,
                way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels,
                carto_label_name(way, name, tags, E'\n') AS name_label
              FROM planet_osm_polygon
              WHERE boundary = 'administrative'
                AND admin_level = '2'
                AND way_area > 100*!pixel_width!::real*!pixel_height!::real
              ORDER BY way_area DESC) AS _
          WHERE name_label[1] IS NOT NULL
        ) AS country_names
    properties:
      minzoom: 2
  - id: capital-names
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            name_label[1] AS name,
            name_label[3] AS font,
            population,
            dir
          FROM
            (SELECT
                way,
                carto_label_name(way, name, tags, E'\n') AS name_label,
                CASE
                  WHEN (tags->'population' ~ '^[0-9]{1,8}$') THEN (tags->'population')::INTEGER ELSE 0
                END AS population,
                round(ascii(md5(osm_id::text)) / 55) AS dir -- base direction factor on geometry to be consistent across metatiles
              FROM planet_osm_point
              WHERE place IN ('city', 'town', 'village', 'hamlet')
                AND tags @> 'capital=>yes'
              ORDER BY population DESC) AS _
          WHERE name_label[1] IS NOT NULL
        ) AS capital_names
    properties:
      minzoom: 3
      maxzoom: 15
  - id: state-names
    class: state
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            way_pixels,
            name_label[1] AS name,
            name_label[3] AS font,
            ref
          FROM
            (SELECT
                way,
                way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels,
                carto_label_name(way, name, tags, E'\n') AS name_label,
                ref
              FROM planet_osm_polygon
              WHERE boundary = 'administrative'
                AND admin_level = '4'
                AND way_area > 100*!pixel_width!::real*!pixel_height!::real
              ORDER BY way_area DESC) AS _
          WHERE name_label[1] IS NOT NULL
        ) AS state_names
    properties:
      minzoom: 4
  - id: placenames-medium
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            name_label[1] AS name,
            name_label[3] AS font,
            score,
            CASE
              WHEN (place = 'city') THEN 1
              ELSE 2
            END as category,
            round(ascii(md5(osm_id::text)) / 55) AS dir -- base direction factor on geometry to be consistent across metatiles
          FROM 
            (SELECT
                osm_id,
                way,
                place,
                carto_label_name(way, name, tags, E'\n') AS name_label,
                (
                  (CASE
                    WHEN (tags->'population' ~ '^[0-9]{1,8}$') THEN (tags->'population')::INTEGER
                    WHEN (place = 'city') THEN 100000
                    WHEN (place = 'town') THEN 1000
                    ELSE 1
                  END)
                  *
                  (CASE
                    WHEN (tags @> 'capital=>4') THEN 2
                    ELSE 1
                  END)
                ) AS score
              FROM planet_osm_point
              WHERE place IN ('city', 'town')
                AND NOT (tags @> 'capital=>yes')
            ) as p
          WHERE name_label[1] IS NOT NULL
          ORDER BY score DESC, length(name_label[1]) DESC, name_label[1]
        ) AS placenames_medium
    properties:
      minzoom: 4
      maxzoom: 15
  - id: placenames-small
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            place,
            -- for debugging: name_label[1]||' '||COALESCE(name_label[2], '')||' '||COALESCE(name_label[3], '') AS name,
            name_label[1] AS name,
            name_label[3] AS font
          FROM
            (SELECT
                way,
                place,
                carto_label_name(way, name, tags, E'\n') AS name_label
              FROM planet_osm_point
              WHERE place IN ('village', 'hamlet')
                 AND NOT tags @> 'capital=>yes'
                 OR place IN ('suburb', 'neighbourhood', 'locality', 'isolated_dwelling', 'farm')) AS _
          WHERE name_label[1] IS NOT NULL
          ORDER BY CASE
              WHEN place = 'suburb' THEN 3
              WHEN place = 'village' THEN 4
              WHEN place = 'hamlet' THEN 5
              WHEN place = 'neighbourhood' THEN 6
              WHEN place = 'locality' THEN 7
              WHEN place = 'isolated_dwelling' THEN 8
              WHEN place = 'farm' THEN 9
            END ASC, length(name_label[1]) DESC, name_label[1]
        ) AS placenames_small
    properties:
      minzoom: 12
  - id: line-barrier-entrances
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      geometry_table: planet_osm_point
      table: |-
        (SELECT way, COALESCE(historic, barrier) AS feature FROM
          (WITH entrance_lines AS
            (SELECT
              ST_Intersection(
                l.way,
                ST_Buffer(
                  e.way,
                  (COALESCE(
                    (SELECT
                       GREATEST(
                         carto_highway_line_width(highway, service, z(!scale_denominator!)),
                         carto_highway_line_width_mapped(highway, tags->'width', tags->'lanes', !bbox!, !scale_denominator!))
                       FROM planet_osm_line h 
                       WHERE ST_Intersects(h.way, e.way) AND highway IN 
                        ('motorway', 'motorway_link', 'trunk', 'trunk_link', 'primary', 'primary_link', 'secondary', 
                         'secondary_link', 'tertiary', 'tertiary_link', 'residential', 'unclassified', 'service', 
                         'living_street', 'pedestrian', 'steps', 'road', 'bridleway', 'footway', 'cycleway', 'path', 'track',
                         'busway', 'bus_guideway')
                        ORDER BY carto_highway_line_width(highway, service, z(!scale_denominator!)) DESC LIMIT 1
                    ),
                    carto_highway_line_width('footway', z(!scale_denominator!))
                  ) + 2.5 + carto_barrier_line_width(
                        CASE WHEN l.historic = 'citywalls' THEN l.historic ELSE l.barrier END,
                        z(!scale_denominator!)
                  ))*0.5*NULLIF(!scale_denominator!*0.001*0.28,0)
                )
              ) AS way,
              ('barrier_' || (CASE WHEN l.barrier IN ('chain', 'city_wall', 'ditch', 'fence', 'guard_rail',
                    'handrail', 'hedge', 'retaining_wall', 'wall') THEN l.barrier ELSE NULL END)) AS barrier,
              ('historic_' || (CASE WHEN l.historic = 'citywalls' THEN l.historic ELSE NULL END)) AS historic
              FROM planet_osm_point e
              JOIN planet_osm_line l ON ST_Intersects(l.way, e.way)
              WHERE e.barrier IN ('entrance')
                AND (e.way && ST_Expand(!bbox!, (0.5*(carto_highway_line_width('motorway', z(!scale_denominator!)) + 2.0 +
                     carto_barrier_line_width('citywalls', z(!scale_denominator!)))*NULLIF(!scale_denominator!*0.001*0.28,0))))
                AND (l.barrier IN ('chain', 'city_wall', 'ditch', 'fence', 'guard_rail',
                    'handrail', 'hedge', 'retaining_wall', 'wall')
                  OR l.historic = 'citywalls')
                AND (l.waterway IS NULL OR l.waterway NOT IN ('river', 'canal', 'derelict_canal', 'stream', 'drain', 'ditch', 'wadi'))
                GROUP BY e.way, l.way, l.barrier, l.historic)
           SELECT
               ST_StartPoint(way) AS way,
               historic, barrier
             FROM entrance_lines
           UNION ALL
           SELECT
               ST_EndPoint(way) AS way,
               historic, barrier
             FROM entrance_lines
          ) AS lbe
        ) AS line_barrier_entrances
    properties:
      minzoom: 16
  - id: amenity-points
    geometry: point
    <<: *extents
    Datasource:
      geometry_table: planet_osm_point
      <<: *osm2pgsql
      table: |-
        (SELECT
            *
          FROM
          ( -- this subselect (with CTE) allows splitting and where necessary duplicating features for separate rendering of symbol and label
            WITH zoom_thresholds AS
            (SELECT -- this subselect generates the zoom level threshols and allows filtering for them
                way,
                "name",
                "lang",
                "font",
                "ref",
                "operator",
                "brand",
                combined.feature AS feature,
                combined.variant AS variant,
                CASE
                  WHEN combined.feature = 'tourism_information' THEN
                    CASE
                      WHEN combined.variant = 'information_audioguide' THEN 19
                      WHEN combined.variant = 'information_board' THEN 19
                      WHEN combined.variant = 'information_guidepost' THEN 19
                      WHEN combined.variant = 'information_map' THEN 19
                      WHEN combined.variant = 'information_terminal' THEN 19
                      ELSE 17
                    END
                  WHEN combined.feature = 'amenity_toilets' THEN
                    CASE
                      WHEN combined.variant = 'access_yes' THEN 17
                      ELSE 18
                    END
                  WHEN combined.feature = 'amenity_recycling' THEN
                    CASE
                      WHEN combined.variant = 'centre' THEN 17
                      ELSE 19
                    END
                  WHEN combined.feature = 'aeroway_aerodrome' THEN
                    CASE
                      WHEN combined.variant = 'public' THEN 10
                      ELSE 11
                    END
                  WHEN combined.feature = 'man_made_mast' THEN
                    CASE
                      WHEN combined.variant = 'height_160' THEN 14
                      WHEN combined.variant = 'height_80' THEN 15
                      WHEN combined.variant = 'height_40' THEN 16
                      WHEN combined.variant = 'height_20' THEN 17
                      ELSE 18
                    END
                  WHEN combined.feature = 'man_made_tower' THEN
                    CASE
                      WHEN combined.variant = 'height_160' THEN 14
                      WHEN combined.variant = 'height_80' THEN 15
                      WHEN combined.variant = 'height_40' THEN 16
                      WHEN combined.variant = 'minor_types' THEN 18
                      ELSE 17
                    END
                  WHEN combined.feature = 'historic_memorial' THEN
                    CASE
                      WHEN combined.variant = 'medium' THEN 18
                      WHEN combined.variant = 'small' THEN 19
                      ELSE 17
                    END
                  WHEN combined.feature = 'historic_castle' THEN
                    CASE
                      WHEN combined.variant = 'minor_types' THEN 16
                      ELSE 15
                    END
                  WHEN combined.feature = 'shop' THEN
                    CASE
                      WHEN combined.variant = 'early' THEN 16
                      ELSE 17
                    END
                  WHEN combined.feature = 'office' THEN
                    CASE
                      WHEN combined.variant = 'diplomatic' THEN 17
                      ELSE 18
                    END
                  WHEN combined.feature IN ('aeroway_helipad', 'amenity_bus_station', 'amenity_cinema', 'amenity_clinic', 'amenity_courthouse', 'amenity_fire_station', 'amenity_hunting_stand', 'amenity_library', 'amenity_place_of_worship', 'amenity_police', 'amenity_shelter', 'amenity_theatre', 'amenity_townhall', 'barrier_toll_booth', 'highway_bus_stop', 'historic_archaeological_site', 'historic_fort', 'historic_manor', 'historic_monument', 'historic_wayside_cross', 'historic_wayside_shrine', 'leisure_beach_resort', 'man_made_cross', 'man_made_windmill', 'tourism_museum', 'tourism_picnic_site', 'tourism_viewpoint') THEN 16
                  WHEN combined.feature IN ('aerialway_station', 'natural_volcano', 'railway_halt', 'railway_tram_stop', 'tourism_alpine_hut', 'tourism_wilderness_hut') THEN 13
                  WHEN combined.feature IN ('aeroway_gate', 'amenity_arts_centre', 'amenity_atm', 'amenity_bank', 'amenity_bar', 'amenity_bbq', 'amenity_bicycle_rental', 'amenity_biergarten', 'amenity_cafe', 'amenity_car_rental', 'amenity_car_wash', 'amenity_charging_station', 'amenity_community_centre', 'amenity_dentist', 'amenity_doctors', 'amenity_drinking_water', 'amenity_driving_school', 'amenity_fast_food', 'amenity_food_court', 'amenity_fountain', 'amenity_fuel', 'amenity_ice_cream', 'amenity_nightclub', 'amenity_pharmacy', 'amenity_phone', 'amenity_post_box', 'amenity_post_office', 'amenity_prison', 'amenity_pub', 'amenity_public_bath', 'amenity_restaurant', 'amenity_social_facility', 'amenity_taxi', 'amenity_veterinary', 'amenity_water_point', 'barrier_block', 'barrier_bollard', 'barrier_gate', 'barrier_lift_gate', 'barrier_log', 'barrier_swing_gate', 'highway_traffic_signals', 'historic_city_gate', 'leisure_firepit', 'leisure_miniature_golf', 'leisure_picnic_table', 'leisure_playground', 'leisure_sauna', 'leisure_slipway', 'man_made_obelisk', 'man_made_water_tap', 'man_made_water_tower', 'military_bunker', 'shop_massage', 'tourism_artwork', 'tourism_camp_site', 'tourism_caravan_site', 'tourism_charlet', 'tourism_guest_house', 'tourism_hostel', 'tourism_hotel', 'tourism_motel') THEN 17
                  WHEN combined.feature IN ('amenity_shower', 'highway_elevator', 'railway_subway_entrance', 'tourism_apartment') THEN 18
                  WHEN combined.feature IN ('amenity_bicycle_parking', 'amenity_motorcycle_parking', 'amenity_parking') THEN GREATEST(10, zoom_threshold)
                  WHEN combined.feature IN ('advertising_column', 'amenity_bench', 'amenity_waste_basket', 'amenity_waste_disposal', 'emergency_phone') THEN 19
                  WHEN combined.feature IN ('amenity_hospital', 'leisure_golf_course', 'man_made_lighthouse', 'man_made_water_well', 'natural_cave_entrance', 'natural_saddle', 'railway_crossing') THEN 15
                  WHEN combined.feature IN ('man_made_communications_tower', 'natural_geyser', 'natural_hot_spring', 'natural_spring', 'railway_level_crossing') THEN 14
                  WHEN combined.feature IN ('railway_station') THEN 12
                  WHEN combined.feature IN ('natural_peak') THEN 11
                  WHEN combined.feature IN ('amenity_marketplace') THEN GREATEST(16, zoom_threshold)
                  WHEN combined.feature IN ('leisure_water_park') THEN GREATEST(14, zoom_threshold)
                END AS start_symbol,
                CASE
                  WHEN combined.feature = 'tourism_information' THEN
                    CASE
                      WHEN combined.variant = 'information_audioguide' THEN 19
                      WHEN combined.variant = 'information_board' THEN 19
                      WHEN combined.variant = 'information_guidepost' THEN 19
                      WHEN combined.variant = 'information_map' THEN 19
                      WHEN combined.variant = 'information_terminal' THEN 19
                      ELSE 17
                    END
                  WHEN combined.feature = 'amenity_recycling' THEN
                    CASE
                      WHEN combined.variant = 'centre' THEN 17
                      ELSE 19
                    END
                  WHEN combined.feature = 'aeroway_aerodrome' THEN
                    CASE
                      WHEN combined.variant = 'public' THEN 10
                      ELSE 11
                    END
                  WHEN combined.feature = 'man_made_tower' THEN
                    CASE
                      WHEN combined.variant = 'height_160' THEN 17
                      WHEN combined.variant = 'height_80' THEN 17
                      WHEN combined.variant = 'height_40' THEN 17
                      WHEN combined.variant = 'minor_types' THEN 19
                      ELSE 18
                    END
                  WHEN combined.feature = 'historic_memorial' THEN
                    CASE
                      WHEN combined.variant = 'medium' THEN 18
                      WHEN combined.variant = 'small' THEN 19
                      ELSE 17
                    END
                  WHEN combined.feature = 'office' THEN
                    CASE
                      WHEN combined.variant = 'diplomatic' THEN 17
                      WHEN combined.variant = 'large' THEN 18
                      ELSE 19
                    END
                  WHEN combined.feature IN ('amenity_arts_centre', 'amenity_atm', 'amenity_bank', 'amenity_bar', 'amenity_bbq', 'amenity_bicycle_rental', 'amenity_biergarten', 'amenity_bus_station', 'amenity_cafe', 'amenity_car_rental', 'amenity_car_wash', 'amenity_charging_station', 'amenity_cinema', 'amenity_clinic', 'amenity_community_centre', 'amenity_courthouse', 'amenity_dentist', 'amenity_doctors', 'amenity_drinking_water', 'amenity_fast_food', 'amenity_fire_station', 'amenity_food_court', 'amenity_fountain', 'amenity_fuel', 'amenity_hunting_stand', 'amenity_ice_cream', 'amenity_library', 'amenity_nightclub', 'amenity_pharmacy', 'amenity_place_of_worship', 'amenity_police', 'amenity_post_office', 'amenity_prison', 'amenity_pub', 'amenity_public_bath', 'amenity_restaurant', 'amenity_shelter', 'amenity_social_facility', 'amenity_taxi', 'amenity_theatre', 'amenity_townhall', 'amenity_veterinary', 'amenity_water_point', 'barrier_toll_booth', 'highway_bus_stop', 'historic_archaeological_site', 'historic_city_gate', 'historic_wayside_cross', 'historic_wayside_shrine', 'leisure_beach_resort', 'leisure_firepit', 'leisure_miniature_golf', 'leisure_picnic_table', 'leisure_playground', 'leisure_sauna', 'leisure_slipway', 'man_made_communications_tower', 'man_made_cross', 'man_made_obelisk', 'man_made_water_tap', 'man_made_water_tower', 'man_made_windmill', 'military_bunker', 'natural_tree', 'shop_massage', 'tourism_artwork', 'tourism_camp_site', 'tourism_caravan_site', 'tourism_charlet', 'tourism_guest_house', 'tourism_hostel', 'tourism_hotel', 'tourism_motel', 'tourism_museum', 'tourism_picnic_site') THEN 17
                  WHEN combined.feature IN ('aerialway_station', 'natural_bay', 'railway_station', 'tourism_alpine_hut', 'tourism_wilderness_hut') THEN 14
                  WHEN combined.feature IN ('amenity_driving_school', 'amenity_shower', 'man_made_mast', 'shop', 'tourism_apartment') THEN 18
                  WHEN combined.feature IN ('aeroway_apron', 'amenity_bicycle_parking', 'amenity_college', 'amenity_grave_yard', 'amenity_kindergarten', 'amenity_motorcycle_parking', 'amenity_parking', 'amenity_school', 'amenity_university', 'landuse_allotments', 'landuse_basin', 'landuse_brownfield', 'landuse_cemetery', 'landuse_commercial', 'landuse_construction', 'landuse_farmland', 'landuse_farmyard', 'landuse_forest', 'landuse_grass', 'landuse_greenhouse_horticulture', 'landuse_landfill', 'landuse_meadow', 'landuse_quarry', 'landuse_recreation_ground', 'landuse_reservoir', 'landuse_village_green', 'leisure_common', 'leisure_dog_park', 'leisure_fitness_centre', 'leisure_fitness_station', 'leisure_garden', 'leisure_park', 'leisure_sport_centre', 'leisure_stadium', 'military_danger_area', 'natural_bare_rock', 'natural_beach', 'natural_glacier', 'natural_grassland', 'natural_heath', 'natural_mud', 'natural_reef', 'natural_sand', 'natural_scree', 'natural_scrub', 'natural_shingle', 'natural_shoal', 'natural_water', 'natural_wetland', 'natural_wood', 'place_archipelago', 'place_island', 'power_generator', 'power_plant', 'shop_mall', 'tourism_theme_park', 'tourism_zoo') THEN GREATEST(10, zoom_threshold)
                  WHEN combined.feature IN ('aeroway_helipad', 'amenity_hospital', 'historic_castle', 'historic_fort', 'historic_manor', 'historic_monument', 'man_made_water_well', 'natural_geyser', 'natural_hot_spring', 'natural_spring', 'railway_tram_stop', 'tourism_viewpoint') THEN 16
                  WHEN combined.feature IN ('railway_subway_entrance') THEN 19
                  WHEN combined.feature IN ('leisure_golf_course', 'man_made_lighthouse', 'natural_cave_entrance', 'natural_saddle', 'natural_volcano', 'railway_halt') THEN 15
                  WHEN combined.feature IN ('natural_peak') THEN 13
                  WHEN combined.feature IN ('man_made_bridge') THEN GREATEST(12, zoom_threshold)
                  WHEN combined.feature IN ('amenity_marketplace') THEN GREATEST(17, zoom_threshold)
                  WHEN combined.feature IN ('leisure_swimming_pool', 'leisure_water_park') THEN GREATEST(14, zoom_threshold)
                  WHEN combined.feature IN ('place_islet') THEN GREATEST(11, zoom_threshold)
                  WHEN combined.feature IN ('highway_rest_area', 'highway_services', 'landuse_garages', 'landuse_industrial', 'landuse_railway', 'landuse_residential', 'landuse_retail', 'man_made_works', 'power_substation') THEN GREATEST(13, zoom_threshold)
                  WHEN combined.feature IN ('leisure_marina') THEN GREATEST(15, zoom_threshold)
                END AS start_label,
                f.prio AS prio,
                "height" AS score,
                "int_elevation",
                "information",
                "int_access",
                "recycling_type",
                "icao",
                "iata",
                "intermittent",
                "drinking_water",
                "int_text_offset",
                "building",
                "height",
                "tower:type",
                "tower:construction",
                "memorial",
                "castle_type",
                "religion",
                "shop",
                "office",
                "diplomatic",
                way_area,
                way_length,
                way_pixels
              FROM
              (SELECT -- this subselect generates the variant and zoom_threshold columns and expands arrays
                  way,
                  "_name_label"[1] AS "name",
                  "_name_label"[2] AS "lang",
                  "_name_label"[3] AS "font",
                  "ref",
                  "operator",
                  "brand",
                  feature,
                  CASE
                    WHEN feature = 'tourism_information' THEN
                      CASE
                        WHEN information IN ('audioguide') THEN 'information_audioguide'
                        WHEN information IN ('board') THEN 'information_board'
                        WHEN information IN ('guidepost') THEN 'information_guidepost'
                        WHEN information IN ('map', 'tactile_map') THEN 'information_map'
                        WHEN information IN ('terminal') THEN 'information_terminal'
                      END
                    WHEN feature = 'amenity_toilets' THEN
                      CASE
                        WHEN int_access = 'yes' THEN 'access_yes'
                      END
                    WHEN feature = 'amenity_recycling' THEN
                      CASE
                        WHEN recycling_type IN ('centre') THEN 'centre'
                      END
                    WHEN feature = 'aeroway_aerodrome' THEN
                      CASE
                        WHEN int_access = 'yes' AND icao IS NOT NULL AND iata IS NOT NULL THEN 'public'
                      END
                    WHEN feature = 'natural_spring' THEN
                      CASE
                        WHEN EXISTS (SELECT 1 FROM planet_osm_line l WHERE ST_DWithin(features.way, l.way, 0.1) AND l.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain')) THEN 'connected'
                      END
                    WHEN feature = 'natural_hot_spring' THEN
                      CASE
                        WHEN EXISTS (SELECT 1 FROM planet_osm_line l WHERE ST_DWithin(features.way, l.way, 0.1) AND l.waterway IN ('river', 'canal', 'stream', 'ditch', 'drain')) THEN 'connected'
                      END
                    WHEN feature = 'man_made_mast' THEN
                      CASE
                        WHEN (height >= 160) AND "tower:type" NOT IN ('lighting') THEN 'height_160'
                        WHEN (height >= 80) AND "tower:type" NOT IN ('lighting') THEN 'height_80'
                        WHEN (height >= 40) AND "tower:type" NOT IN ('lighting') THEN 'height_40'
                        WHEN (height >= 20) AND "tower:type" NOT IN ('lighting') THEN 'height_20'
                      END
                    WHEN feature = 'man_made_tower' THEN
                      CASE
                        WHEN (height >= 160) AND "tower:type" NOT IN ('lighting', 'bell_tower') THEN 'height_160'
                        WHEN (height >= 80) AND "tower:type" NOT IN ('lighting', 'bell_tower') THEN 'height_80'
                        WHEN (height >= 40) AND "tower:type" NOT IN ('lighting', 'bell_tower') THEN 'height_40'
                        WHEN "tower:type" IN ('lighting', 'bell_tower') THEN 'minor_types'
                      END
                    WHEN feature = 'historic_memorial' THEN
                      CASE
                        WHEN memorial IN ('bust', 'stele', 'stone') THEN 'medium'
                        WHEN memorial IN ('plaque', 'blue_plaque') THEN 'small'
                      END
                    WHEN feature = 'historic_castle' THEN
                      CASE
                        WHEN castle_type IN ('stately', 'manor') THEN 'minor_types'
                      END
                    WHEN feature = 'shop' THEN
                      CASE
                        WHEN shop IN ('supermarket', 'department_store') THEN 'early'
                      END
                    WHEN feature = 'office' THEN
                      CASE
                        WHEN diplomatic IN ('embassy', 'consulate') THEN 'diplomatic'
                        WHEN office IN ('accountant', 'adoption_agency', 'advertising_agency', 'architect', 'association', 'charity', 'company', 'educational_institution', 'employment_agency',  'energy_supplier', 'estate_agent', 'financial', 'forestry', 'foundation', 'government', 'guide', 'insurance', 'it', 'lawyer', 'logistics', 'moving_company', 'newspaper', 'ngo', 'notary', 'political_party', 'private_investigator', 'property_management', 'quango', 'religion', 'research', 'surveyor', 'tax', 'tax_advisor', 'telecommunication', 'travel_agent', 'water_utility') THEN 'large'
                      END
                  END AS variant,
                  CASE
                    WHEN feature IN ('amenity_bicycle_parking', 'amenity_motorcycle_parking', 'amenity_parking') THEN LEAST(zoom_from_pixelsize(SQRT(way_area/900)::numeric), 17)
                    WHEN feature IN ('aeroway_apron', 'amenity_college', 'amenity_grave_yard', 'amenity_kindergarten', 'amenity_marketplace', 'amenity_school', 'amenity_university', 'highway_rest_area', 'highway_services', 'landuse_allotments', 'landuse_basin', 'landuse_brownfield', 'landuse_cemetery', 'landuse_commercial', 'landuse_construction', 'landuse_farmland', 'landuse_farmyard', 'landuse_forest', 'landuse_garages', 'landuse_grass', 'landuse_greenhouse_horticulture', 'landuse_industrial', 'landuse_landfill', 'landuse_meadow', 'landuse_quarry', 'landuse_railway', 'landuse_recreation_ground', 'landuse_reservoir', 'landuse_residential', 'landuse_retail', 'landuse_village_green', 'leisure_common', 'leisure_dog_park', 'leisure_fitness_centre', 'leisure_fitness_station', 'leisure_garden', 'leisure_marina', 'leisure_park', 'leisure_sport_centre', 'leisure_stadium', 'leisure_swimming_pool', 'leisure_water_park', 'man_made_works', 'military_danger_area', 'natural_bare_rock', 'natural_beach', 'natural_grassland', 'natural_heath', 'natural_mud', 'natural_reef', 'natural_sand', 'natural_scree', 'natural_scrub', 'natural_shingle', 'natural_shoal', 'natural_water', 'natural_wetland', 'natural_wood', 'place_islet', 'power_generator', 'power_plant', 'power_substation', 'shop_mall', 'tourism_theme_park', 'tourism_zoo') THEN LEAST(zoom_from_pixelsize(SQRT(way_area/3000)::numeric), 17)
                    WHEN feature IN ('man_made_bridge') THEN zoom_from_pixelsize(SQRT(way_area/62.5)::numeric)
                    WHEN feature IN ('place_archipelago', 'place_island') THEN LEAST(zoom_from_pixelsize(SQRT(way_area/3000)::numeric), 16)
                    WHEN feature IN ('natural_glacier') THEN LEAST(zoom_from_pixelsize(SQRT(way_area/750)::numeric), 17)
                  END AS zoom_threshold,
                  "int_elevation",
                  "information",
                  "int_access",
                  "recycling_type",
                  "icao",
                  "iata",
                  "intermittent",
                  "drinking_water",
                  "int_text_offset",
                  "building",
                  "height",
                  "tower:type",
                  "tower:construction",
                  "memorial",
                  "castle_type",
                  "religion",
                  "shop",
                  "office",
                  "diplomatic",
                  way_area,
                  way_length,
                  way_pixels
                FROM
                (SELECT -- This subselect generates the feature column allows filtering on it
                    way,
                    carto_label_name(way, name, tags, E'\n') AS "_name_label",
                    "name",
                    "ref",
                    "operator",
                    "brand",
                    COALESCE(
                      'aeroway_' || CASE WHEN "aeroway" IN ('aerodrome', 'gate', 'helipad') AND (way_length IS NULL) THEN "aeroway" END,
                      'aeroway_' || CASE WHEN "aeroway" IN ('apron') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "aeroway" END,
                      'tourism_' || CASE WHEN "tourism" IN ('alpine_hut', 'apartment', 'artwork', 'camp_site', 'caravan_site', 'charlet', 'guest_house', 'hostel', 'hotel', 'motel', 'museum', 'picnic_site', 'viewpoint', 'wilderness_hut') AND (way_length IS NULL) THEN "tourism" END,
                      'tourism_' || CASE WHEN "tourism" IN ('information') AND (way_length IS NULL) AND (tags->'information' IN ('audioguide', 'board', 'guidepost', 'map', 'office', 'tactile_map', 'terminal')) THEN "tourism" END,
                      'tourism_' || CASE WHEN "tourism" IN ('theme_park', 'zoo') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "tourism" END,
                      'amenity_' || CASE WHEN "amenity" IN ('arts_centre', 'atm', 'bank', 'bar', 'bbq', 'bench', 'bicycle_parking', 'bicycle_rental', 'biergarten', 'bus_station', 'cafe', 'car_rental', 'car_wash', 'charging_station', 'cinema', 'clinic', 'community_centre', 'courthouse', 'dentist', 'doctors', 'drinking_water', 'driving_school', 'fast_food', 'fire_station', 'food_court', 'fountain', 'fuel', 'hospital', 'hunting_stand', 'ice_cream', 'library', 'marketplace', 'motorcycle_parking', 'nightclub', 'parking', 'pharmacy', 'phone', 'place_of_worship', 'police', 'post_box', 'post_office', 'prison', 'pub', 'public_bath', 'recycling', 'restaurant', 'shelter', 'shower', 'social_facility', 'taxi', 'theatre', 'toilets', 'townhall', 'veterinary', 'waste_basket', 'water_point') AND (way_length IS NULL) THEN "amenity" END,
                      'amenity_' || CASE WHEN "amenity" IN ('waste_disposal') AND (way_length IS NULL) AND ("access" IS NULL OR "access" NOT IN ('private', 'no', 'customers', 'permit', 'delivery')) THEN "amenity" END,
                      'amenity_' || CASE WHEN "amenity" IN ('college', 'grave_yard', 'kindergarten', 'school', 'university') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "amenity" END,
                      'office' || CASE WHEN (way_length IS NULL) AND (office IS NOT NULL AND office NOT IN ('yes', 'no', 'vacant', 'closed', 'disused', 'empty')) THEN '' END,
                      'advertising_' || CASE WHEN "advertising" IN ('column') AND (way_length IS NULL) THEN "advertising" END,
                      'emergency_' || CASE WHEN "emergency" IN ('phone') AND (way_length IS NULL) THEN "emergency" END,
                      'shop_' || CASE WHEN "shop" IN ('mall', 'massage') AND (way_length IS NULL) THEN "shop" END,
                      'shop' || CASE WHEN (way_length IS NULL) AND (shop IS NOT NULL AND shop NOT IN ('yes', 'no', 'vacant', 'closed', 'disused', 'empty', 'mall', 'massage')) THEN '' END,
                      'leisure_' || CASE WHEN "leisure" IN ('beach_resort', 'firepit', 'golf_course', 'miniature_golf', 'picnic_table', 'playground', 'sauna', 'slipway', 'water_park') AND (way_length IS NULL) THEN "leisure" END,
                      'leisure_' || CASE WHEN "leisure" IN ('common', 'dog_park', 'fitness_centre', 'fitness_station', 'garden', 'marina', 'park', 'sport_centre', 'stadium', 'swimming_pool') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "leisure" END,
                      'power_' || CASE WHEN "power" IN ('generator') AND (way_length IS NULL) AND (tags->'generator:type' IS NULL OR tags->'generator:type' NOT IN ('wind')) THEN "power" END,
                      'power_' || CASE WHEN "power" IN ('plant', 'substation') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "power" END,
                      'man_made_' || CASE WHEN "man_made" IN ('bridge', 'communications_tower', 'cross', 'lighthouse', 'mast', 'obelisk', 'tower', 'water_tap', 'water_tower', 'water_well', 'windmill') AND (way_length IS NULL) THEN "man_made" END,
                      'man_made_' || CASE WHEN "man_made" IN ('works') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "man_made" END,
                      'landuse_' || CASE WHEN "landuse" IN ('allotments', 'basin', 'brownfield', 'cemetery', 'commercial', 'construction', 'farmland', 'farmyard', 'forest', 'garages', 'grass', 'greenhouse_horticulture', 'industrial', 'landfill', 'meadow', 'quarry', 'railway', 'recreation_ground', 'reservoir', 'residential', 'retail', 'village_green') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "landuse" END,
                      'natural_' || CASE WHEN "natural" IN ('bay', 'cave_entrance', 'geyser', 'hot_spring', 'peak', 'saddle', 'spring', 'tree', 'volcano') AND (way_length IS NULL) THEN "natural" END,
                      'natural_' || CASE WHEN "natural" IN ('bare_rock', 'beach', 'glacier', 'grassland', 'heath', 'mud', 'reef', 'sand', 'scree', 'scrub', 'shingle', 'shoal', 'water', 'wetland', 'wood') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "natural" END,
                      'waterway_' || CASE WHEN "waterway" IN ('waterfall') AND (way_length IS NULL) THEN "waterway" END,
                      'place_' || CASE WHEN "place" IN ('archipelago') AND (way_area IS NOT NULL) AND (way_length IS NULL) THEN "place" END,
                      'place_' || CASE WHEN "place" IN ('island', 'islet') AND (way_length IS NULL) THEN "place" END,
                      'historic_' || CASE WHEN "historic" IN ('archaeological_site', 'castle', 'city_gate', 'fort', 'manor', 'memorial', 'monument', 'wayside_cross', 'wayside_shrine') AND (way_length IS NULL) THEN "historic" END,
                      'military_' || CASE WHEN "military" IN ('bunker') AND (way_length IS NULL) THEN "military" END,
                      'military_' || CASE WHEN "military" IN ('danger_area') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "military" END,
                      'highway_' || CASE WHEN "highway" IN ('bus_stop', 'traffic_signals') AND (way_length IS NULL) THEN "highway" END,
                      'highway_' || CASE WHEN "highway" IN ('elevator') AND (way_length IS NULL) AND ("access" IS NULL OR "access" NOT IN ('private', 'no', 'customers', 'permit', 'delivery')) THEN "highway" END,
                      'highway_' || CASE WHEN "highway" IN ('rest_area', 'services') AND (way_length IS NULL) AND (building IS NULL OR building = 'no') THEN "highway" END,
                      'barrier_' || CASE WHEN "barrier" IN ('block', 'bollard', 'gate', 'lift_gate', 'log', 'swing_gate', 'toll_booth') AND (way_length IS NULL) THEN "barrier" END,
                      'railway_' || CASE WHEN "railway" IN ('crossing', 'halt', 'level_crossing', 'station', 'subway_entrance', 'tram_stop') AND (way_length IS NULL) THEN "railway" END,
                      'aerialway_' || CASE WHEN "aerialway" IN ('station') AND (way_length IS NULL) THEN "aerialway" END
                    ) AS feature,
                    CASE
                      WHEN "amenity" IN ('shelter') OR "tourism" IN ('alpine_hut', 'wilderness_hut') OR "natural" IN ('peak', 'saddle', 'volcano') THEN
                        CASE WHEN (tags ? 'ele') AND tags->'ele' ~ '^-?\d{1,4}(\.\d+)?$' THEN CONCAT(E'\n', REPLACE(ROUND((tags->'ele')::NUMERIC)::TEXT, '-', U&'\2212'), U&'\00A0', 'm') END
                    END AS "int_elevation",
                    "information",
                    CASE WHEN "access" IN ('private', 'no', 'customers', 'permit', 'delivery') THEN 'restricted' ELSE 'yes' END AS "int_access",
                    "recycling_type",
                    "icao",
                    "iata",
                    CASE
                      WHEN "natural" IN ('hot_spring', 'spring') THEN
                        CASE WHEN tags->'intermittent' IN ('yes') OR tags->'seasonal' IN ('yes') THEN 'yes' END
                    END AS "intermittent",
                    CASE WHEN amenity = 'drinking_water' OR (tags->'drinking_water') = 'yes' THEN 'yes' END AS "drinking_water",
                    CASE
                      WHEN "natural" IN ('tree') THEN
                        ROUND(GREATEST(
                          carto_barrier_line_width('tree', z(!scale_denominator!)),
                          LEAST(carto_tree_diameter_mapped('tree', diameter_crown, height, circumference, diameter, !bbox!, !scale_denominator!), 60)
                        )*0.5)+2.0
                    END AS "int_text_offset",
                    "building",
                    CASE
                      WHEN (("man_made" IN ('mast', 'tower')) AND (tags->'location' NOT IN ('roof', 'rooftop') OR (tags->'location') IS NULL)) OR
                            ("waterway" IN ('waterfall')) THEN
                        CASE WHEN height ~ '^\d{1,3}(\.\d+)?( m)?$' THEN (SUBSTRING(height, '^(\d{1,3}(\.\d+)?)( m)?$'))::NUMERIC END
                    END AS "height",
                    "tower:type",
                    "tower:construction",
                    "memorial",
                    "castle_type",
                    CASE
                      WHEN "amenity" IN ('place_of_worship') THEN
                        CASE WHEN religion IN ('christian') AND tags->'denomination' IN ('jehovahs_witness', 'la_luz_del_mundo', 'iglesia_ni_cristo', 'mormon') THEN NULL ELSE religion END
                    END AS "religion",
                    CASE WHEN shop IN ('supermarket', 'bag', 'bakery', 'beauty', 'bed', 'bookmaker', 'books', 'butcher', 'carpet', 'clothes', 'computer',
                                       'confectionery', 'fashion', 'convenience', 'department_store', 'doityourself', 'hardware', 'fabric', 'fishmonger', 'florist',
                                       'garden_centre', 'hairdresser', 'hifi', 'car', 'car_repair', 'bicycle', 'mall', 'pet',
                                       'photo', 'photo_studio', 'photography', 'seafood', 'shoes', 'alcohol', 'gift', 'furniture', 'kiosk',
                                       'mobile_phone', 'motorcycle', 'musical_instrument', 'newsagent', 'optician', 'jewelry', 'jewellery',
                                       'electronics', 'chemist', 'toys', 'travel_agency', 'car_parts', 'greengrocer', 'farm', 'stationery',
                                       'laundry', 'dry_cleaning', 'beverages', 'perfumery', 'cosmetics', 'variety_store', 'wine', 'outdoor',
                                       'copyshop', 'sports', 'deli', 'tobacco', 'art', 'tea', 'coffee', 'tyres', 'pastry', 'chocolate',
                                       'music', 'medical_supply', 'dairy', 'video_games', 'houseware', 'ticket', 'charity', 'second_hand',
                                       'interior_decoration', 'video', 'paint', 'massage', 'trade', 'wholesale') THEN shop
                      ELSE 'other' END AS "shop",
                    "office",
                    "diplomatic",
                    way_length,
                    way_area,
                    COALESCE(way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0), 0) AS way_pixels
                  FROM
                  (
                    SELECT
                        way,
                        "access",
                        "aerialway",
                        "aeroway",
                        "amenity",
                        "barrier",
                        "building",
                        "highway",
                        "historic",
                        "landuse",
                        "leisure",
                        "man_made",
                        "military",
                        "name",
                        "natural",
                        "place",
                        "power",
                        "railway",
                        "ref",
                        "religion",
                        "shop",
                        "tourism",
                        "waterway",
                        tags->'advertising' AS "advertising",
                        tags->'brand' AS "brand",
                        tags->'castle_type' AS "castle_type",
                        tags->'circumference' AS "circumference",
                        tags->'diameter' AS "diameter",
                        tags->'diameter_crown' AS "diameter_crown",
                        tags->'diplomatic' AS "diplomatic",
                        tags->'drinking_water' AS "drinking_water",
                        tags->'emergency' AS "emergency",
                        tags->'height' AS "height",
                        tags->'iata' AS "iata",
                        tags->'icao' AS "icao",
                        tags->'information' AS "information",
                        tags->'intermittent' AS "intermittent",
                        tags->'memorial' AS "memorial",
                        tags->'office' AS "office",
                        tags->'operator' AS "operator",
                        tags->'recycling_type' AS "recycling_type",
                        tags->'tower:construction' AS "tower:construction",
                        tags->'tower:type' AS "tower:type",
                        tags,
                        NULL AS way_length,
                        NULL AS way_area
                      FROM planet_osm_point
                     WHERE way && !bbox!
                    UNION ALL
                    SELECT
                        ST_PointOnSurface(way) AS way,
                        "access",
                        "aerialway",
                        "aeroway",
                        "amenity",
                        "barrier",
                        "building",
                        "highway",
                        "historic",
                        "landuse",
                        "leisure",
                        "man_made",
                        "military",
                        "name",
                        "natural",
                        "place",
                        "power",
                        "railway",
                        "ref",
                        "religion",
                        "shop",
                        "tourism",
                        "waterway",
                        tags->'advertising' AS "advertising",
                        tags->'brand' AS "brand",
                        tags->'castle_type' AS "castle_type",
                        tags->'circumference' AS "circumference",
                        tags->'diameter' AS "diameter",
                        tags->'diameter_crown' AS "diameter_crown",
                        tags->'diplomatic' AS "diplomatic",
                        tags->'drinking_water' AS "drinking_water",
                        tags->'emergency' AS "emergency",
                        tags->'height' AS "height",
                        tags->'iata' AS "iata",
                        tags->'icao' AS "icao",
                        tags->'information' AS "information",
                        tags->'intermittent' AS "intermittent",
                        tags->'memorial' AS "memorial",
                        tags->'office' AS "office",
                        tags->'operator' AS "operator",
                        tags->'recycling_type' AS "recycling_type",
                        tags->'tower:construction' AS "tower:construction",
                        tags->'tower:type' AS "tower:type",
                        tags,
                        NULL AS way_length,
                        way_area
                      FROM planet_osm_polygon
                      WHERE way && !bbox!
                        AND way_area < 768000*POW(!scale_denominator!*0.001*0.28,2)
                        AND ("place" NOT IN ('archipelago') OR "place" IS NULL)
                    UNION ALL
                    SELECT -- This is separately the archipelagos with the convex hull geometry processing
                        ST_ClosestPoint(oway,ST_PointOnSurface(way)) AS way,
                        "access",
                        "aerialway",
                        "aeroway",
                        "amenity",
                        "barrier",
                        "building",
                        "highway",
                        "historic",
                        "landuse",
                        "leisure",
                        "man_made",
                        "military",
                        "name",
                        "natural",
                        "place",
                        "power",
                        "railway",
                        "ref",
                        "religion",
                        "shop",
                        "tourism",
                        "waterway",
                        tags->'advertising' AS "advertising",
                        tags->'brand' AS "brand",
                        tags->'castle_type' AS "castle_type",
                        tags->'circumference' AS "circumference",
                        tags->'diameter' AS "diameter",
                        tags->'diameter_crown' AS "diameter_crown",
                        tags->'diplomatic' AS "diplomatic",
                        tags->'drinking_water' AS "drinking_water",
                        tags->'emergency' AS "emergency",
                        tags->'height' AS "height",
                        tags->'iata' AS "iata",
                        tags->'icao' AS "icao",
                        tags->'information' AS "information",
                        tags->'intermittent' AS "intermittent",
                        tags->'memorial' AS "memorial",
                        tags->'office' AS "office",
                        tags->'operator' AS "operator",
                        tags->'recycling_type' AS "recycling_type",
                        tags->'tower:construction' AS "tower:construction",
                        tags->'tower:type' AS "tower:type",
                        tags,
                        NULL AS way_length,
                        ST_Area(ST_Envelope(oway)) AS way_area
                      FROM
                        (SELECT
                            (ST_Dump(
                              -- this detects multipolygons extending over the 180 degree meridian to split them
                              CASE WHEN (ST_XMax(way)-ST_XMin(way)) < 20037508 THEN
                                ST_ConvexHull(way)
                              ELSE
                                -- splits the polygon into the two hemisphere parts
                                ST_Collect(
                                  ST_ConvexHull(ST_Intersection(way, ST_SetSRID(ST_GeomFromText('POLYGON((-20037508 -20037508, -20037508 20037508, 0  20037508, 0 -20037508, -20037508 -20037508))'), 3857))),
                                  ST_ConvexHull(ST_Intersection(way, ST_SetSRID(ST_GeomFromText('POLYGON((0 -20037508, 0 20037508, 20037508 20037508, 20037508 -20037508, 0 -20037508))'), 3857)))
                                )
                              END
                            )).geom AS way,
                            way AS oway,
                            "access",
                            "aerialway",
                            "aeroway",
                            "amenity",
                            "barrier",
                            "building",
                            "highway",
                            "historic",
                            "landuse",
                            "leisure",
                            "man_made",
                            "military",
                            "name",
                            "natural",
                            "place",
                            "power",
                            "railway",
                            "ref",
                            "religion",
                            "shop",
                            "tourism",
                            "waterway",
                            tags
                          FROM planet_osm_polygon
                          WHERE way && !bbox!
                            AND building IS NULL
                            AND "place" IN ('archipelago')
                        ) AS archipelagos
                  ) AS _
                ) AS features
                WHERE feature IS NOT NULL
              ) AS combined
              JOIN (VALUES
                  ('aeroway_helipad', 1),
                  ('aeroway_aerodrome+public', 2),
                  ('aeroway_aerodrome', 3),
                  ('aeroway_gate', 4),
                  ('aeroway_apron', 5),
                  ('tourism_alpine_hut', 6),
                  ('tourism_wilderness_hut', 7),
                  ('tourism_charlet', 8),
                  ('tourism_hostel', 9),
                  ('tourism_hotel', 10),
                  ('tourism_motel', 11),
                  ('tourism_guest_house', 12),
                  ('tourism_apartment', 13),
                  ('tourism_museum', 14),
                  ('tourism_viewpoint', 15),
                  ('tourism_artwork', 16),
                  ('tourism_camp_site', 17),
                  ('tourism_caravan_site', 18),
                  ('tourism_picnic_site', 19),
                  ('tourism_information+information_audioguide', 20),
                  ('tourism_information+information_board', 21),
                  ('tourism_information+information_guidepost', 22),
                  ('tourism_information+information_map', 23),
                  ('tourism_information+information_terminal', 24),
                  ('tourism_information', 25),
                  ('tourism_theme_park', 26),
                  ('tourism_zoo', 27),
                  ('amenity_shelter', 28),
                  ('amenity_atm', 29),
                  ('amenity_bank', 30),
                  ('amenity_bar', 31),
                  ('amenity_bbq', 32),
                  ('amenity_cafe', 33),
                  ('amenity_ice_cream', 34),
                  ('amenity_nightclub', 35),
                  ('amenity_pub', 36),
                  ('amenity_biergarten', 37),
                  ('amenity_restaurant', 38),
                  ('amenity_food_court', 39),
                  ('amenity_fast_food', 40),
                  ('amenity_fire_station', 41),
                  ('amenity_cinema', 42),
                  ('amenity_library', 43),
                  ('amenity_courthouse', 44),
                  ('amenity_townhall', 45),
                  ('amenity_police', 46),
                  ('amenity_prison', 47),
                  ('amenity_post_box', 48),
                  ('amenity_post_office', 49),
                  ('amenity_theatre', 50),
                  ('amenity_arts_centre', 51),
                  ('amenity_community_centre', 52),
                  ('amenity_social_facility', 53),
                  ('amenity_shower', 54),
                  ('amenity_public_bath', 55),
                  ('amenity_toilets+access_yes', 56),
                  ('amenity_toilets', 57),
                  ('amenity_parking', 58),
                  ('amenity_motorcycle_parking', 59),
                  ('amenity_bicycle_parking', 60),
                  ('amenity_bicycle_rental', 61),
                  ('amenity_bus_station', 62),
                  ('amenity_car_rental', 63),
                  ('amenity_car_wash', 64),
                  ('amenity_charging_station', 65),
                  ('amenity_fuel', 66),
                  ('amenity_taxi', 67),
                  ('amenity_phone', 68),
                  ('amenity_bench', 69),
                  ('amenity_waste_basket', 70),
                  ('amenity_recycling+centre', 71),
                  ('amenity_recycling', 72),
                  ('amenity_drinking_water', 73),
                  ('amenity_water_point', 74),
                  ('amenity_fountain', 75),
                  ('amenity_hunting_stand', 76),
                  ('amenity_place_of_worship', 77),
                  ('amenity_hospital', 78),
                  ('amenity_pharmacy', 79),
                  ('amenity_dentist', 80),
                  ('amenity_doctors', 81),
                  ('amenity_clinic', 82),
                  ('amenity_veterinary', 83),
                  ('amenity_driving_school', 84),
                  ('amenity_marketplace', 85),
                  ('amenity_waste_disposal', 86),
                  ('amenity_grave_yard', 87),
                  ('amenity_kindergarten', 88),
                  ('amenity_school', 89),
                  ('amenity_college', 90),
                  ('amenity_university', 91),
                  ('office+diplomatic', 92),
                  ('office+large', 93),
                  ('office', 94),
                  ('advertising_column', 95),
                  ('emergency_phone', 96),
                  ('shop_massage', 97),
                  ('shop_mall', 98),
                  ('shop+early', 99),
                  ('shop', 100),
                  ('leisure_water_park', 101),
                  ('leisure_playground', 102),
                  ('leisure_miniature_golf', 103),
                  ('leisure_golf_course', 104),
                  ('leisure_picnic_table', 105),
                  ('leisure_firepit', 106),
                  ('leisure_sauna', 107),
                  ('leisure_beach_resort', 108),
                  ('leisure_slipway', 109),
                  ('leisure_fitness_centre', 110),
                  ('leisure_fitness_station', 111),
                  ('leisure_dog_park', 112),
                  ('leisure_swimming_pool', 113),
                  ('leisure_common', 114),
                  ('leisure_garden', 115),
                  ('leisure_sport_centre', 116),
                  ('leisure_stadium', 117),
                  ('leisure_park', 118),
                  ('leisure_marina', 119),
                  ('power_generator', 120),
                  ('power_plant', 121),
                  ('power_substation', 122),
                  ('man_made_water_tap', 123),
                  ('man_made_water_well', 124),
                  ('man_made_windmill', 125),
                  ('man_made_water_tower', 126),
                  ('man_made_lighthouse', 127),
                  ('man_made_mast+height_160', 128),
                  ('man_made_mast+height_80', 129),
                  ('man_made_mast+height_40', 130),
                  ('man_made_mast+height_20', 131),
                  ('man_made_mast', 132),
                  ('man_made_tower+height_160', 133),
                  ('man_made_tower+height_80', 134),
                  ('man_made_tower+height_40', 135),
                  ('man_made_tower+minor_types', 136),
                  ('man_made_tower', 137),
                  ('man_made_communications_tower', 138),
                  ('man_made_obelisk', 139),
                  ('man_made_cross', 140),
                  ('man_made_bridge', 141),
                  ('man_made_works', 142),
                  ('landuse_garages', 143),
                  ('landuse_retail', 144),
                  ('landuse_residential', 145),
                  ('landuse_industrial', 146),
                  ('landuse_railway', 147),
                  ('landuse_cemetery', 148),
                  ('landuse_commercial', 149),
                  ('landuse_quarry', 150),
                  ('landuse_brownfield', 151),
                  ('landuse_landfill', 152),
                  ('landuse_construction', 153),
                  ('landuse_village_green', 154),
                  ('landuse_meadow', 155),
                  ('landuse_grass', 156),
                  ('landuse_allotments', 157),
                  ('landuse_farmyard', 158),
                  ('landuse_farmland', 159),
                  ('landuse_greenhouse_horticulture', 160),
                  ('landuse_forest', 161),
                  ('landuse_reservoir', 162),
                  ('landuse_basin', 163),
                  ('landuse_recreation_ground', 164),
                  ('natural_spring+connected', 165),
                  ('natural_spring', 166),
                  ('natural_hot_spring+connected', 167),
                  ('natural_hot_spring', 168),
                  ('natural_geyser', 169),
                  ('natural_bay', 170),
                  ('natural_tree', 171),
                  ('natural_peak', 172),
                  ('natural_volcano', 173),
                  ('natural_saddle', 174),
                  ('natural_cave_entrance', 175),
                  ('natural_grassland', 176),
                  ('natural_wood', 177),
                  ('natural_wetland', 178),
                  ('natural_reef', 179),
                  ('natural_mud', 180),
                  ('natural_heath', 181),
                  ('natural_scrub', 182),
                  ('natural_beach', 183),
                  ('natural_shoal', 184),
                  ('natural_sand', 185),
                  ('natural_scree', 186),
                  ('natural_shingle', 187),
                  ('natural_bare_rock', 188),
                  ('natural_glacier', 189),
                  ('natural_water', 190),
                  ('waterway_waterfall', 191),
                  ('place_archipelago', 192),
                  ('place_island', 193),
                  ('place_islet', 194),
                  ('historic_city_gate', 195),
                  ('historic_memorial+medium', 196),
                  ('historic_memorial+small', 197),
                  ('historic_memorial', 198),
                  ('historic_monument', 199),
                  ('historic_fort', 200),
                  ('historic_castle+minor_types', 201),
                  ('historic_castle', 202),
                  ('historic_manor', 203),
                  ('historic_archaeological_site', 204),
                  ('historic_wayside_cross', 205),
                  ('historic_wayside_shrine', 206),
                  ('military_bunker', 207),
                  ('military_danger_area', 208),
                  ('highway_bus_stop', 209),
                  ('highway_traffic_signals', 210),
                  ('highway_elevator', 211),
                  ('highway_services', 212),
                  ('highway_rest_area', 213),
                  ('barrier_gate', 214),
                  ('barrier_lift_gate', 215),
                  ('barrier_swing_gate', 216),
                  ('barrier_bollard', 217),
                  ('barrier_block', 218),
                  ('barrier_log', 219),
                  ('barrier_toll_booth', 220),
                  ('railway_crossing', 221),
                  ('railway_level_crossing', 222),
                  ('railway_subway_entrance', 223),
                  ('railway_station', 224),
                  ('railway_halt', 225),
                  ('railway_tram_stop', 226),
                  ('aerialway_station', 227)
                ) AS f (feature, prio)
                ON f.feature = CONCAT(combined.feature, '+'||combined.variant)
            ) -- end of zoom_thresholds CTE
            SELECT -- this is the combined symbol/label features - only on those zoom levels where they are shown
                way,
                "name",
                "lang",
                "font",
                "ref",
                "operator",
                "brand",
                feature,
                variant,
                start_symbol,
                start_label,
                prio,
                CASE
                  WHEN z(!scale_denominator!) >= start_symbol THEN
                    CASE
                      WHEN z(!scale_denominator!) >= start_label THEN
                        'symbol-label'
                      ELSE
                        'symbol-only'
                    END
                  WHEN z(!scale_denominator!) >= start_label THEN
                    'label-only'
                END AS vis_type,
                "int_elevation",
                "information",
                "int_access",
                "recycling_type",
                "icao",
                "iata",
                "intermittent",
                "drinking_water",
                "int_text_offset",
                "building",
                "height",
                "tower:type",
                "tower:construction",
                "memorial",
                "castle_type",
                "religion",
                "shop",
                "office",
                "diplomatic",
                way_area,
                way_length,
                way_pixels
              FROM zoom_thresholds
              WHERE z(!scale_denominator!) >= LEAST(start_symbol, start_label)
          ) AS final
          ORDER BY
            (CASE
              WHEN start_symbol IS NULL THEN start_label
              WHEN start_label IS NULL THEN start_symbol
              ELSE 0.5*(start_symbol+start_label)
            END) ASC NULLS LAST,
            prio ASC NULLS LAST,
            way_pixels DESC NULLS LAST,
            way_length DESC NULLS LAST
        ) AS amenity_points
    properties:
      minzoom: 10
  - id: power-towers
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM planet_osm_point
          WHERE power = 'tower'
        ) AS power_towers
    properties:
      minzoom: 14
  - id: power-poles
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM planet_osm_point
          WHERE power = 'pole'
        ) AS power_poles
    properties:
      minzoom: 16
  - id: roads-text-ref-low-zoom
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            highway,
            height,
            width,
            refs
          FROM (
            SELECT
                way,
                osm_id,
                highway,
                array_length(refs,1) AS height,
                (SELECT MAX(char_length(ref)) FROM unnest(refs) AS u(ref)) AS width,
                array_to_string(refs, E'\n') AS refs
              FROM (
                SELECT
                    way,
                    osm_id,
                    highway,
                    string_to_array(ref, ';') AS refs
                FROM planet_osm_roads
                  WHERE highway IN ('motorway', 'trunk', 'primary', 'secondary')
                  AND ref IS NOT NULL
              ) AS p) AS q
          WHERE height <= 4 AND width <= 11
          ORDER BY
            CASE
              WHEN highway = 'motorway' THEN 38
              WHEN highway = 'trunk' THEN 37
              WHEN highway = 'primary' THEN 36
              WHEN highway = 'secondary' THEN 35
              WHEN highway = 'tertiary' THEN 34
              WHEN highway = 'unclassified' THEN 33
              WHEN highway = 'residential' THEN 32
              WHEN highway = 'runway' THEN 6
              WHEN highway = 'taxiway' THEN 5
              ELSE NULL
            END DESC NULLS LAST,
            height DESC,
            width DESC,
            refs,
            osm_id
        ) AS roads_text_ref_low_zoom
    properties:
      minzoom: 10
      maxzoom: 12
  - id: junctions
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            highway,
            junction,
            ref,
            name_label[1] AS name,
            name_label[3] AS font
          FROM
            (SELECT
                way,
                highway,
                junction,
                ref,
                carto_label_name(way, name, tags, E'\n') AS name_label
              FROM planet_osm_point
              WHERE highway = 'motorway_junction' OR highway = 'traffic_signals' OR junction = 'yes') AS _
        ) AS junctions
    properties:
      minzoom: 11
  - id: roads-text-ref
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            highway,
            height,
            width,
            refs
          FROM (
            SELECT
                osm_id,
                way,
                highway,
                array_length(refs,1) AS height,
                (SELECT MAX(char_length(ref)) FROM unnest(refs) AS u(ref)) AS width,
                array_to_string(refs, E'\n') AS refs
              FROM (
                SELECT
                    osm_id,
                    way,
                    COALESCE(
                      CASE WHEN highway IN ('motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'unclassified', 'busway', 'bus_guideway', 'residential') THEN highway ELSE NULL END,
                      CASE WHEN aeroway IN ('runway', 'taxiway') THEN aeroway ELSE NULL END
                    ) AS highway,
                    string_to_array(ref, ';') AS refs
                  FROM planet_osm_line
                  WHERE (highway IN ('motorway', 'trunk', 'primary', 'secondary', 'tertiary', 'unclassified', 'busway', 'bus_guideway', 'residential') OR aeroway IN ('runway', 'taxiway'))
                    AND ref IS NOT NULL
              ) AS p) AS q
          WHERE height <= 4 AND width <= 11
          ORDER BY
            CASE
              WHEN highway = 'motorway' THEN 38
              WHEN highway = 'trunk' THEN 37
              WHEN highway = 'primary' THEN 36
              WHEN highway = 'secondary' THEN 35
              WHEN highway = 'tertiary' THEN 34
              WHEN highway = 'unclassified' THEN 33
              WHEN highway = 'residential' THEN 32
              WHEN highway = 'bus_guideway' THEN 31
              WHEN highway = 'busway' THEN 30
              WHEN highway = 'runway' THEN 6
              WHEN highway = 'taxiway' THEN 5
              ELSE NULL
            END DESC NULLS LAST,
            height DESC,
            width DESC,
            refs,
            osm_id
        ) AS roads_text_ref
    properties:
      minzoom: 13
  - id: roads-area-text-name
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            way_pixels,
            highway,
            name_label[1] AS name,
            name_label[3] AS font
          FROM
            (SELECT
                way,
                way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels,
                COALESCE(highway, railway) AS highway,
                carto_label_name(way, name, tags, E'\n') AS name_label
              FROM planet_osm_polygon
              WHERE highway IN ('residential', 'unclassified', 'pedestrian', 'service', 'footway', 'track', 'path', 'platform')
                OR railway IN ('platform')) AS _
          WHERE name_label[1] IS NOT NULL
          ORDER BY way_pixels DESC
        ) AS roads_area_text_name
    properties:
      minzoom: 15
  - id: roads-text-name
    class: directions
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            highway,
            tunnel,
            construction,
            name_label[1] AS name,
            name_label[3] AS font,
            -- name,
            oneway,
            path_type
          FROM
            (SELECT
                way,
                CASE WHEN substr(highway, length(highway)-4, 5) = '_link' THEN substr(highway, 0, length(highway)-4) ELSE highway END AS highway,
                CASE WHEN (tunnel = 'yes' OR tunnel = 'building_passage' OR covered = 'yes') THEN 'yes' ELSE 'no' END AS tunnel,
                construction,
                carto_label_name(way, name, tags, ' - ') AS name_label,
                name,
                CASE
                  WHEN oneway IN ('yes', '-1') THEN oneway
                  WHEN junction IN ('roundabout') AND (oneway IS NULL OR NOT oneway IN ('no', 'reversible')) THEN 'yes'
                  ELSE NULL
                END AS oneway,
                carto_path_type(foot, bicycle, horse) AS path_type,
                z_order,
                COALESCE(layer, 0) AS layernotnull,
                l.osm_id AS osm_id
              FROM planet_osm_line l
              JOIN (VALUES -- this join is also putting a condition on what is selected. features not matching it do not make it into the results.
                  ('motorway', 380),
                  ('trunk', 370),
                  ('primary', 360),
                  ('secondary', 350),
                  ('tertiary', 340),
                  ('residential', 330),
                  ('unclassified', 330),
                  ('road', 330),
                  ('living_street', 320),
                  ('pedestrian', 310),
                  ('raceway', 300),
                  ('motorway_link', 240),
                  ('trunk_link', 230),
                  ('primary_link', 220),
                  ('secondary_link', 210),
                  ('tertiary_link', 200),
                  ('bus_guideway', 190),
                  ('busway', 180),
                  ('service', 150),
                  ('construction', 10)
                ) AS ordertable (highway, prio)
                USING (highway)
              WHERE highway IN ('motorway', 'motorway_link', 'trunk', 'trunk_link', 'primary', 'primary_link', 'secondary', 'secondary_link',
              'tertiary', 'tertiary_link', 'residential', 'unclassified', 'road', 'service', 'pedestrian', 'raceway', 'living_street',
              'construction', 'busway', 'bus_guideway')) AS _
          ORDER BY
            z_order DESC, -- put important roads first
            layernotnull, -- put top layered roads first
            length(name) DESC, -- Try to fit big labels in first
            name DESC, -- Force a consistent ordering between differently named streets
            osm_id DESC -- Force an ordering for streets of the same name, e.g. dualized roads
        ) AS roads_text_name
    properties:
      minzoom: 13
  - id: paths-text-name
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            highway,
            name_label[1] AS name,
            name_label[3] AS font
          FROM
            (SELECT
                way,
                highway,
                carto_label_name(way, name, tags, ' - ') AS name_label
              FROM planet_osm_line
              WHERE highway IN ('bridleway', 'footway', 'cycleway', 'path', 'track', 'steps')) AS _
        ) AS paths_text_name
    properties:
      minzoom: 15
  - id: text-poly-low-zoom
    class: text-low-zoom
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            way_pixels,
            feature,
            name_label[1] AS name,
            name_label[3] AS font,
            is_building
          FROM
            (SELECT
                way,
                way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels,
                COALESCE(
                  'landuse_' || CASE WHEN landuse IN ('forest', 'military') THEN landuse ELSE NULL END,
                  'natural_' || CASE WHEN "natural" IN ('wood', 'glacier', 'sand', 'scree', 'shingle', 'bare_rock') THEN "natural" ELSE NULL END,
                  'place_' || CASE WHEN place IN ('island') THEN place ELSE NULL END
                ) AS feature,
                carto_label_name(way, name, tags, E'\n') AS name_label,
                'no' AS is_building
              FROM planet_osm_polygon
              WHERE (landuse IN ('forest', 'military')
                  OR "natural" IN ('wood', 'glacier', 'sand', 'scree', 'shingle', 'bare_rock')
                  OR "place" IN ('island'))
                AND building IS NULL
             UNION ALL
             SELECT
                ST_ClosestPoint(oway,ST_PointOnSurface(way)),
                ST_Area(ST_Envelope(oway))/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels,
                'place_archipelago' AS feature,
                name_label,
                'no' AS is_building
             FROM
               (SELECT
                  (ST_Dump(
                    -- this detects multipolygons extending over the 180 degree meridian to split them
                    CASE WHEN (ST_XMax(way)-ST_XMin(way)) < 20037508 THEN
                      ST_ConvexHull(way)
                    ELSE
                      -- splits the polygon into the two hemisphere parts
                      ST_Collect(
                        ST_ConvexHull(ST_Intersection(way, ST_SetSRID(ST_GeomFromText('POLYGON((-20037508 -20037508, -20037508 20037508, 0 20037508, 0 -20037508, -20037508 -20037508))'), 3857))),
                        ST_ConvexHull(ST_Intersection(way, ST_SetSRID(ST_GeomFromText('POLYGON((0 -20037508, 0 20037508, 20037508 20037508, 20037508 -20037508, 0 -20037508))'), 3857)))
                      )
                    END
                  )).geom AS way,
                  way AS oway,
                  carto_label_name(way, name, tags, E'\n') AS name_label
                FROM planet_osm_polygon
                WHERE "place" IN ('archipelago')
                  AND building IS NULL
              ) AS archipelagos
            ) AS labels
          WHERE name_label[1] IS NOT NULL
          ORDER BY way_pixels DESC
        ) AS text_poly_low_zoom
    properties:
      minzoom: 4
      maxzoom: 9
  - id: text-line
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            way_pixels,
            feature,
            access,
            name_label[1] AS name,
            name_label[3] AS font,
            operator,
            ref,
            way_area,
            is_building
          FROM
            (SELECT
                way,
                NULL as way_pixels,
                COALESCE('man_made_' || man_made, 'waterway_' || waterway, 'natural_' || "natural") AS feature,
                access,
                carto_label_name(way, name, tags, E'\n') AS name_label,
                tags->'operator' as operator,
                ref,
                NULL AS way_area,
                CASE WHEN building = 'no' OR building IS NULL THEN 'no' ELSE 'yes' END AS is_building
              FROM planet_osm_line
              WHERE (man_made IN ('pier', 'breakwater', 'groyne', 'embankment')
                  OR waterway IN ('dam', 'weir', 'lock_gate')
                  OR "natural" IN ('cliff', 'earth_bank'))) AS _
          WHERE name_label[1] IS NOT NULL OR ref IS NOT NULL OR operator IS NOT NULL
        ) AS text_line
    properties:
      minzoom: 10
  - id: building-text
    geometry: polygon
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            name_label[1] AS name,
            name_label[3] AS font,
            way_pixels
          FROM
            (SELECT
                way,
                carto_label_name(way, name, tags, E'\n') AS name_label,
                way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels
              FROM planet_osm_polygon
              WHERE building IS NOT NULL
                AND building NOT IN ('no')) AS _
          WHERE name_label[1] IS NOT NULL
          ORDER BY way_pixels DESC
        ) AS building_text
    properties:
      minzoom: 14
  - id: interpolation
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way
          FROM planet_osm_line
          WHERE "addr:interpolation" IS NOT NULL
        ) AS interpolation
    properties:
      minzoom: 17
  - id: addresses
    geometry: point
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            "addr:housenumber" AS addr_housenumber,
            "addr:housename" AS addr_housename,
            tags->'addr:unit' AS addr_unit,
            way_area/NULLIF(POW(!scale_denominator!*0.001*0.28,2),0) AS way_pixels
          FROM planet_osm_polygon
          WHERE (("addr:housenumber" IS NOT NULL) OR ("addr:housename" IS NOT NULL) OR ((tags->'addr:unit') IS NOT NULL))
            AND building IS NOT NULL
        UNION ALL
        SELECT
            way,
            "addr:housenumber" AS addr_housenumber,
            "addr:housename" AS addr_housename,
            tags->'addr:unit' AS addr_unit,
            NULL AS way_pixels
          FROM planet_osm_point
          WHERE ("addr:housenumber" IS NOT NULL) OR ("addr:housename" IS NOT NULL) OR ((tags->'addr:unit') IS NOT NULL)
          ORDER BY way_pixels DESC NULLS LAST
        ) AS addresses
    properties:
      minzoom: 17
  - id: water-lines-text
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            waterway,
            lock,
            name_label[1] AS name,
            name_label[3] AS font,
            intermittent,
            seasonal,
            int_tunnel
          FROM
            (SELECT
                way,
                waterway,
                lock,
                carto_label_name(way, name, tags, ' - ') AS name_label,
                tags->'intermittent' as intermittent,
                tags->'seasonal' as seasonal,
                CASE WHEN tunnel IN ('yes', 'culvert') THEN 'yes' ELSE 'no' END AS int_tunnel,
                COALESCE(layer,0) AS layernotnull
              FROM planet_osm_line
              WHERE waterway IN ('river', 'canal', 'stream', 'drain', 'ditch', 'wadi')
                AND (tunnel IS NULL or tunnel != 'culvert')) AS _
          WHERE name_label[1] IS NOT NULL
          ORDER BY layernotnull
        ) AS water_lines_text
    properties:
      minzoom: 13
  - id: ferry-routes-text
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            name_label[1] AS name,
            name_label[3] AS font
          FROM
            (SELECT
                way,
                carto_label_name(way, name, tags, E'\n') AS name_label
              FROM planet_osm_line
              WHERE route = 'ferry') AS _
          WHERE name_label[1] IS NOT NULL
        ) AS ferry_routes_text
    properties:
      minzoom: 13
  - id: admin-text
    geometry: linestring
    <<: *extents
    Datasource:
      <<: *osm2pgsql
      table: |-
        (SELECT
            way,
            name_label[1] AS name,
            name_label[3] AS font,
            admin_level
          FROM
            (SELECT
                way,
                carto_label_name(way, name, tags, E'\n') AS name_label,
                admin_level,
                way_area
              FROM planet_osm_polygon
              WHERE boundary = 'administrative'
                AND admin_level IN ('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10')) AS _
          WHERE name_label[1] IS NOT NULL
          ORDER BY admin_level::integer ASC, way_area DESC
        ) AS admin_text
    properties:
      minzoom: 16
